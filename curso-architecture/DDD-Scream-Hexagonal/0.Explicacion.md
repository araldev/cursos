# ğŸ—ï¸ Tutorial: Screaming + Hexagonal Architecture

## ğŸ“‹ ConstrucciÃ³n Paso a Paso (Iterativa)

> **Objetivo**: Construir una arquitectura que "grite" el propÃ³sito del negocio con infraestructura encapsulada por bounded context.

---

## ğŸ¯ **VisiÃ³n General**

Al final tendremos esta estructura:

```
ğŸ“¦ Mi-AplicaciÃ³n
â”œâ”€â”€ ğŸ¢ src/ (LÃ³gica de Negocio)
â”‚   â”œâ”€â”€ ğŸ“¦ order-management/
â”‚   â”‚   â”œâ”€â”€ ğŸ¯ domain/
â”‚   â”‚   â”œâ”€â”€ âš¡ application/
â”‚   â”‚   â””â”€â”€ ğŸ”Œ infrastructure/
â”‚   â””â”€â”€ ğŸ‘¥ user-management/
â”‚       â”œâ”€â”€ ğŸ¯ domain/
â”‚       â”œâ”€â”€ âš¡ application/
â”‚       â””â”€â”€ ğŸ”Œ infrastructure/
â”œâ”€â”€ ğŸšª entrypoints/ (Puntos de Entrada)
â”‚   â””â”€â”€ ğŸŒ web/
â”œâ”€â”€ ğŸ”„ shared/ (Servicios Compartidos)
â””â”€â”€ âš™ï¸ config/ (Configuraciones)
```

---

## ğŸ—ºï¸ **Roadmap del Tutorial**

### **ğŸŸ¦ FASE 1**: Estructura Base (15 min)

- Crear carpetas principales
- Configurar TypeScript
- Setup bÃ¡sico

### **ğŸŸ¨ FASE 2**: Primer Bounded Context (30 min)

- Order Management completo
- Domain â†’ Application â†’ Infrastructure

### **ğŸŸ© FASE 3**: ConexiÃ³n Base de Datos (20 min)

- Pool compartido
- Primer repositorio funcionando

### **ğŸŸª FASE 4**: Web Entrypoint (25 min)

- Express server
- Controllers y rutas
- Dependency injection

### **ğŸŸ§ FASE 5**: Segundo Bounded Context (20 min)

- User Management
- Reutilizar patrones

### **ğŸŸ¥ FASE 6**: Testing y Refinamiento (20 min)

- Tests bÃ¡sicos
- DocumentaciÃ³n
- Mejoras finales

**â±ï¸ Tiempo total estimado: 2 horas 10 minutos**

---

## ğŸŸ¦ **FASE 1: Estructura Base** (15 min)

### **ğŸ“‹ Paso 1.1: Crear Proyecto** (5 min)

#### ğŸ¯ **Objetivo**: Configurar el proyecto base

#### ğŸ”§ **Acciones**:

1. Crear carpeta del proyecto
2. Inicializar npm
3. Instalar dependencias bÃ¡sicas

#### ğŸ“ **Estructura esperada**:

```
mi-app/
â”œâ”€â”€ ğŸ“„ package.json
â”œâ”€â”€ ğŸ“„ tsconfig.json
â””â”€â”€ ğŸ“„ .env.example
```

#### âœ… **Resultado**: Proyecto TypeScript funcional

---

### **ğŸ“‹ Paso 1.2: Estructura de Carpetas** (5 min)

#### ğŸ¯ **Objetivo**: Crear la estructura principal

#### ğŸ”§ **Acciones**:

1. Crear carpeta `src/`
2. Crear carpeta `entrypoints/`
3. Crear carpeta `shared/`
4. Crear carpeta `config/`

#### ğŸ“ **Estructura esperada**:

```
mi-app/
â”œâ”€â”€ ğŸ“‚ src/
â”œâ”€â”€ ğŸ“‚ entrypoints/
â”œâ”€â”€ ğŸ“‚ shared/
â”œâ”€â”€ ğŸ“‚ config/
â”œâ”€â”€ ğŸ“„ package.json
â””â”€â”€ ğŸ“„ tsconfig.json
```

#### âœ… **Resultado**: Estructura base lista

---

### **ğŸ“‹ Paso 1.3: Configuraciones** (5 min)

#### ğŸ¯ **Objetivo**: Configurar TypeScript y environment

#### ğŸ”§ **Acciones**:

1. Configurar `tsconfig.json`
2. Crear `.env.example`
3. Configurar scripts en `package.json`

#### âœ… **Resultado**: Proyecto configurado y compilable

---

## ğŸŸ¨ **FASE 2: Primer Bounded Context** (30 min)

### **ğŸ“‹ Paso 2.1: Order Management - Domain** (10 min)

#### ğŸ¯ **Objetivo**: Crear el corazÃ³n del negocio

#### ğŸ”§ **Acciones**:

1. Crear `src/order-management/domain/`
2. Crear subcarpetas: `entities/`, `value-objects/`, `repositories/`, `services/`
3. Crear archivos base para cada subcarpeta

#### ğŸ“ **Estructura esperada**:

```
src/order-management/domain/
â”œâ”€â”€ ğŸ“‚ entities/
â”‚   â”œâ”€â”€ ğŸ“„ Order.ts
â”‚   â””â”€â”€ ğŸ“„ OrderItem.ts
â”œâ”€â”€ ğŸ“‚ value-objects/
â”‚   â”œâ”€â”€ ğŸ“„ OrderId.ts
â”‚   â”œâ”€â”€ ğŸ“„ Money.ts
â”‚   â””â”€â”€ ğŸ“„ OrderStatus.ts
â”œâ”€â”€ ğŸ“‚ repositories/
â”‚   â””â”€â”€ ğŸ“„ OrderRepository.ts (interface)
â””â”€â”€ ğŸ“‚ services/
    â””â”€â”€ ğŸ“„ OrderPricingService.ts
```

#### ğŸ’¡ **Tip Visual**:

```
ğŸ¯ DOMAIN = LÃ³gica de negocio PURA
â”œâ”€â”€ ğŸ‘¤ Entities = Objetos con identidad
â”œâ”€â”€ ğŸ’ Value Objects = Objetos inmutables
â”œâ”€â”€ ğŸ“„ Repositories = Contratos
â””â”€â”€ ğŸ§  Services = LÃ³gica compleja
```

#### âœ… **Resultado**: Domain layer completo

---

### **ğŸ“‹ Paso 2.2: Order Management - Application** (10 min)

#### ğŸ¯ **Objetivo**: Crear casos de uso y puertos

#### ğŸ”§ **Acciones**:

1. Crear `src/order-management/application/`
2. Crear `use-cases/` y `ports/`
3. Crear archivos de casos de uso principales

#### ğŸ“ **Estructura esperada**:

```
src/order-management/application/
â”œâ”€â”€ ğŸ“‚ use-cases/
â”‚   â”œâ”€â”€ ğŸ“„ CreateOrderUseCase.ts
â”‚   â”œâ”€â”€ ğŸ“„ ProcessPaymentUseCase.ts
â”‚   â””â”€â”€ ğŸ“„ CancelOrderUseCase.ts
â””â”€â”€ ğŸ“‚ ports/
    â”œâ”€â”€ ğŸ“„ PaymentProcessingPort.ts
    â””â”€â”€ ğŸ“„ InventoryManagementPort.ts
```

#### ğŸ’¡ **Tip Visual**:

```
âš¡ APPLICATION = Casos de uso especÃ­ficos
â”œâ”€â”€ ğŸ­ Use Cases = "Quiero crear una orden"
â””â”€â”€ ğŸ”Œ Ports = Interfaces hacia afuera
```

#### âœ… **Resultado**: Application layer completo

---

### **ğŸ“‹ Paso 2.3: Order Management - Infrastructure** (10 min)

#### ğŸ¯ **Objetivo**: Crear adaptadores externos

#### ğŸ”§ **Acciones**:

1. Crear `src/order-management/infrastructure/`
2. Crear subcarpetas: `repositories/`, `external-services/`
3. Crear Factory del bounded context

#### ğŸ“ **Estructura esperada**:

```
src/order-management/infrastructure/
â”œâ”€â”€ ğŸ“‚ repositories/
â”‚   â””â”€â”€ ğŸ“„ PostgreSQLOrderRepository.ts
â”œâ”€â”€ ğŸ“‚ external-services/
â”‚   â””â”€â”€ ğŸ“„ StripePaymentService.ts
â””â”€â”€ ğŸ“„ OrderManagementFactory.ts
```

#### ğŸ’¡ **Tip Visual**:

```
ğŸ”Œ INFRASTRUCTURE = Adaptadores al mundo real
â”œâ”€â”€ ğŸ—„ï¸ Repositories = Implementaciones de BD
â”œâ”€â”€ ğŸŒ External Services = APIs externas
â””â”€â”€ ğŸ­ Factory = Ensambla todo el context
```

#### âœ… **Resultado**: Infrastructure layer completo

---

## ğŸŸ© **FASE 3: ConexiÃ³n Base de Datos** (20 min)

### **ğŸ“‹ Paso 3.1: Database Shared** (10 min)

#### ğŸ¯ **Objetivo**: Crear conexiÃ³n compartida

#### ğŸ”§ **Acciones**:

1. Crear `shared/database/`
2. Implementar connection pool
3. Configurar variables de entorno

#### ğŸ“ **Estructura esperada**:

```
shared/database/
â”œâ”€â”€ ğŸ“„ connection.ts
â””â”€â”€ ğŸ“„ migrations/ (carpeta)
```

#### ğŸ’¡ **Tip Visual**:

```
ğŸ”„ SHARED = Recursos compartidos
â””â”€â”€ ğŸ”Œ Database = Un pool para todos
    â”œâ”€â”€ ğŸª Order Context usa el pool
    â””â”€â”€ ğŸ‘¥ User Context usa el MISMO pool
```

#### âœ… **Resultado**: Pool de conexiones funcionando

---

### **ğŸ“‹ Paso 3.2: Primer Repositorio Real** (10 min)

#### ğŸ¯ **Objetivo**: Conectar Order Repository a la BD

#### ğŸ”§ **Acciones**:

1. Implementar `PostgreSQLOrderRepository`
2. Conectar con el pool compartido
3. Crear mÃ©todos bÃ¡sicos (save, findById)

#### ğŸ’¡ **Tip Visual**:

```
ğŸ”„ Flujo de Datos:
Use Case â†’ Repository Interface â†’ PostgreSQL Implementation â†’ Pool â†’ Database
```

#### âœ… **Resultado**: Primer repositorio conectado a BD

---

## ğŸŸª **FASE 4: Web Entrypoint** (25 min)

### **ğŸ“‹ Paso 4.1: Estructura Web** (5 min)

#### ğŸ¯ **Objetivo**: Crear estructura del entrypoint web

#### ğŸ”§ **Acciones**:

1. Crear `entrypoints/web/`
2. Crear subcarpetas: `controllers/`, `routes/`
3. Crear archivos base

#### ğŸ“ **Estructura esperada**:

```
entrypoints/web/
â”œâ”€â”€ ğŸ“‚ controllers/
â”‚   â””â”€â”€ ğŸ“„ OrderController.ts
â”œâ”€â”€ ğŸ“‚ routes/
â”‚   â””â”€â”€ ğŸ“„ orderRoutes.ts
â”œâ”€â”€ ğŸ“„ app.ts
â””â”€â”€ ğŸ“„ server.ts
```

#### âœ… **Resultado**: Estructura web lista

---

### **ğŸ“‹ Paso 4.2: Order Controller** (10 min)

#### ğŸ¯ **Objetivo**: Crear controlador para Ã³rdenes

#### ğŸ”§ **Acciones**:

1. Implementar `OrderController`
2. MÃ©todos: createOrder, getOrder, processPayment, cancelOrder
3. Usar factory pattern para dependencias

#### ğŸ’¡ **Tip Visual**:

```
ğŸŒ HTTP Request
    â†“
ğŸ® Controller (traduce HTTP â†” Domain)
    â†“
ğŸ­ Factory (crea use cases)
    â†“
âš¡ Use Case (lÃ³gica de aplicaciÃ³n)
    â†“
ğŸ—„ï¸ Repository (persiste datos)
```

#### âœ… **Resultado**: Controller funcionando

---

### **ğŸ“‹ Paso 4.3: Express App** (10 min)

#### ğŸ¯ **Objetivo**: Configurar Express con dependency injection

#### ğŸ”§ **Acciones**:

1. Crear `app.ts` con configuraciÃ³n Express
2. Implementar dependency injection manual
3. Conectar rutas con controllers

#### ğŸ’¡ **Tip Visual**:

```
ğŸš€ Server Start
    â†“
ğŸ”Œ Create Database Pool
    â†“
ğŸ­ Create Factories (inject pool)
    â†“
ğŸ® Create Controllers (inject factories)
    â†“
ğŸ›¤ï¸ Setup Routes (inject controllers)
    â†“
ğŸ“± Express App Ready
```

#### âœ… **Resultado**: API REST funcionando

---

## ğŸŸ© **FASE 5: Segundo Bounded Context** (20 min)

### **ğŸ“‹ Paso 5.1: User Management Structure** (10 min)

#### ğŸ¯ **Objetivo**: Crear User Management siguiendo el mismo patrÃ³n

#### ğŸ”§ **Acciones**:

1. Copiar estructura de Order Management
2. Adaptar para User domain
3. Crear Factory correspondiente

#### ğŸ“ **Estructura esperada**:

```
src/user-management/
â”œâ”€â”€ ğŸ“‚ domain/
â”œâ”€â”€ ğŸ“‚ application/
â””â”€â”€ ğŸ“‚ infrastructure/
    â””â”€â”€ ğŸ“„ UserManagementFactory.ts
```

#### ğŸ’¡ **Tip Visual**:

```
ğŸª Order Management        ğŸ‘¥ User Management
â”œâ”€â”€ ğŸ¯ domain/            â”œâ”€â”€ ğŸ¯ domain/
â”œâ”€â”€ âš¡ application/       â”œâ”€â”€ âš¡ application/
â””â”€â”€ ğŸ”Œ infrastructure/    â””â”€â”€ ğŸ”Œ infrastructure/

ğŸ“‹ Mismo patrÃ³n, diferente dominio
```

#### âœ… **Resultado**: Segundo bounded context estructurado

---

### **ğŸ“‹ Paso 5.2: User Web Integration** (10 min)

#### ğŸ¯ **Objetivo**: Integrar User Management con web entrypoint

#### ğŸ”§ **Acciones**:

1. Crear `UserController`
2. Crear `userRoutes`
3. Integrar en `app.ts`

#### ğŸ’¡ **Tip Visual**:

```
ğŸ“± Express App
â”œâ”€â”€ ğŸ›¤ï¸ /api/orders/* â†’ OrderController â†’ OrderFactory
â””â”€â”€ ğŸ›¤ï¸ /api/users/* â†’ UserController â†’ UserFactory

ğŸ”„ Cada controller usa su factory independiente
```

#### âœ… **Resultado**: API completa con dos bounded contexts

---

## ğŸŸ¥ **FASE 6: Testing y Refinamiento** (20 min)

### **ğŸ“‹ Paso 6.1: Testing BÃ¡sico** (10 min)

#### ğŸ¯ **Objetivo**: Crear tests para validar funcionamiento

#### ğŸ”§ **Acciones**:

1. Configurar Jest
2. Test de domain entities
3. Test de use cases
4. Test de API endpoints

#### ğŸ“ **Estructura esperada**:

```
tests/
â”œâ”€â”€ ğŸ“‚ unit/
â”‚   â”œâ”€â”€ ğŸ“‚ order-management/
â”‚   â””â”€â”€ ğŸ“‚ user-management/
â”œâ”€â”€ ğŸ“‚ integration/
â””â”€â”€ ğŸ“‚ e2e/
```

#### âœ… **Resultado**: Tests bÃ¡sicos funcionando

---

### **ğŸ“‹ Paso 6.2: DocumentaciÃ³n y Scripts** (10 min)

#### ğŸ¯ **Objetivo**: Documentar y facilitar uso

#### ğŸ”§ **Acciones**:

1. Crear README.md completo
2. Configurar scripts de npm
3. Crear documentaciÃ³n de API
4. Setup de development workflow

#### ğŸ“ **Estructura final**:

```
mi-app/
â”œâ”€â”€ ğŸ“‚ src/
â”‚   â”œâ”€â”€ ğŸ“‚ order-management/
â”‚   â””â”€â”€ ğŸ“‚ user-management/
â”œâ”€â”€ ğŸ“‚ entrypoints/
â”‚   â””â”€â”€ ğŸ“‚ web/
â”œâ”€â”€ ğŸ“‚ shared/
â”œâ”€â”€ ğŸ“‚ tests/
â”œâ”€â”€ ğŸ“‚ docs/
â”œâ”€â”€ ğŸ“„ README.md
â””â”€â”€ ğŸ“„ package.json
```

#### âœ… **Resultado**: Proyecto completo y documentado

---

## ğŸ‰ **Resultado Final**

### **âœ… Lo que has logrado**:

1. **ğŸ—ï¸ Arquitectura Screaming**: Los nombres de carpeta gritan el propÃ³sito
2. **ğŸ”„ Hexagonal Architecture**: SeparaciÃ³n clara de capas
3. **ğŸ“¦ Bounded Contexts**: Cada dominio encapsulado
4. **ğŸ”Œ Infrastructure Independiente**: Cada context maneja su infra
5. **ğŸšª Multiple Entrypoints**: Preparado para web, CLI, messaging
6. **ğŸ”„ Shared Resources**: Eficiencia con recursos compartidos
7. **ğŸ§ª Testeable**: Estructura que facilita testing
8. **ğŸ“ˆ Escalable**: FÃ¡cil agregar nuevos bounded contexts

### **ğŸš€ PrÃ³ximos pasos sugeridos**:

1. **ğŸ“¨ Agregar Events**: Para comunicaciÃ³n entre contexts
2. **ğŸ’» CLI Entrypoint**: Para operaciones administrativas
3. **ğŸ³ Dockerizar**: Para deployment fÃ¡cil
4. **ğŸ“Š Monitoring**: Logs, mÃ©tricas, health checks
5. **ğŸ”’ Security**: AutenticaciÃ³n, autorizaciÃ³n
6. **ğŸ“± Frontend**: React/Vue que consuma la API

### **ğŸ¯ Conceptos clave aprendidos**:

- **Screaming Architecture**: La estructura debe gritar el negocio
- **Bounded Contexts**: EncapsulaciÃ³n por dominio
- **Dependency Inversion**: Infrastructure depende de Domain
- **Factory Pattern**: Ensamblaje de dependencias
- **Shared Resources**: Eficiencia sin acoplamiento
- **Iterative Development**: ConstrucciÃ³n paso a paso

---

## ğŸ“š **Recursos Adicionales**

- **ğŸ“– Domain-Driven Design** (Eric Evans)
- **ğŸ›ï¸ Clean Architecture** (Robert Martin)
- **ğŸ“ Hexagonal Architecture** (Alistair Cockburn)
- **ğŸ”„ Event Storming** para descubrir bounded contexts

---

\*\*ğŸŠ Â¡Felicitaciones! Has construido una arquitectura robusta, escalable y
