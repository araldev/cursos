# 🏗️ Tutorial: Screaming + Hexagonal Architecture

## 📋 Construcción Paso a Paso (Iterativa)

> **Objetivo**: Construir una arquitectura que "grite" el propósito del negocio con infraestructura encapsulada por bounded context.

---

## 🎯 **Visión General**

Al final tendremos esta estructura:

```
📦 Mi-Aplicación
├── 🏢 src/ (Lógica de Negocio)
│   ├── 📦 order-management/
│   │   ├── 🎯 domain/
│   │   ├── ⚡ application/
│   │   └── 🔌 infrastructure/
│   └── 👥 user-management/
│       ├── 🎯 domain/
│       ├── ⚡ application/
│       └── 🔌 infrastructure/
├── 🚪 entrypoints/ (Puntos de Entrada)
│   └── 🌐 web/
├── 🔄 shared/ (Servicios Compartidos)
└── ⚙️ config/ (Configuraciones)
```

---

## 🗺️ **Roadmap del Tutorial**

### **🟦 FASE 1**: Estructura Base (15 min)

- Crear carpetas principales
- Configurar TypeScript
- Setup básico

### **🟨 FASE 2**: Primer Bounded Context (30 min)

- Order Management completo
- Domain → Application → Infrastructure

### **🟩 FASE 3**: Conexión Base de Datos (20 min)

- Pool compartido
- Primer repositorio funcionando

### **🟪 FASE 4**: Web Entrypoint (25 min)

- Express server
- Controllers y rutas
- Dependency injection

### **🟧 FASE 5**: Segundo Bounded Context (20 min)

- User Management
- Reutilizar patrones

### **🟥 FASE 6**: Testing y Refinamiento (20 min)

- Tests básicos
- Documentación
- Mejoras finales

**⏱️ Tiempo total estimado: 2 horas 10 minutos**

---

## 🟦 **FASE 1: Estructura Base** (15 min)

### **📋 Paso 1.1: Crear Proyecto** (5 min)

#### 🎯 **Objetivo**: Configurar el proyecto base

#### 🔧 **Acciones**:

1. Crear carpeta del proyecto
2. Inicializar npm
3. Instalar dependencias básicas

#### 📁 **Estructura esperada**:

```
mi-app/
├── 📄 package.json
├── 📄 tsconfig.json
└── 📄 .env.example
```

#### ✅ **Resultado**: Proyecto TypeScript funcional

---

### **📋 Paso 1.2: Estructura de Carpetas** (5 min)

#### 🎯 **Objetivo**: Crear la estructura principal

#### 🔧 **Acciones**:

1. Crear carpeta `src/`
2. Crear carpeta `entrypoints/`
3. Crear carpeta `shared/`
4. Crear carpeta `config/`

#### 📁 **Estructura esperada**:

```
mi-app/
├── 📂 src/
├── 📂 entrypoints/
├── 📂 shared/
├── 📂 config/
├── 📄 package.json
└── 📄 tsconfig.json
```

#### ✅ **Resultado**: Estructura base lista

---

### **📋 Paso 1.3: Configuraciones** (5 min)

#### 🎯 **Objetivo**: Configurar TypeScript y environment

#### 🔧 **Acciones**:

1. Configurar `tsconfig.json`
2. Crear `.env.example`
3. Configurar scripts en `package.json`

#### ✅ **Resultado**: Proyecto configurado y compilable

---

## 🟨 **FASE 2: Primer Bounded Context** (30 min)

### **📋 Paso 2.1: Order Management - Domain** (10 min)

#### 🎯 **Objetivo**: Crear el corazón del negocio

#### 🔧 **Acciones**:

1. Crear `src/order-management/domain/`
2. Crear subcarpetas: `entities/`, `value-objects/`, `repositories/`, `services/`
3. Crear archivos base para cada subcarpeta

#### 📁 **Estructura esperada**:

```
src/order-management/domain/
├── 📂 entities/
│   ├── 📄 Order.ts
│   └── 📄 OrderItem.ts
├── 📂 value-objects/
│   ├── 📄 OrderId.ts
│   ├── 📄 Money.ts
│   └── 📄 OrderStatus.ts
├── 📂 repositories/
│   └── 📄 OrderRepository.ts (interface)
└── 📂 services/
    └── 📄 OrderPricingService.ts
```

#### 💡 **Tip Visual**:

```
🎯 DOMAIN = Lógica de negocio PURA
├── 👤 Entities = Objetos con identidad
├── 💎 Value Objects = Objetos inmutables
├── 📄 Repositories = Contratos
└── 🧠 Services = Lógica compleja
```

#### ✅ **Resultado**: Domain layer completo

---

### **📋 Paso 2.2: Order Management - Application** (10 min)

#### 🎯 **Objetivo**: Crear casos de uso y puertos

#### 🔧 **Acciones**:

1. Crear `src/order-management/application/`
2. Crear `use-cases/` y `ports/`
3. Crear archivos de casos de uso principales

#### 📁 **Estructura esperada**:

```
src/order-management/application/
├── 📂 use-cases/
│   ├── 📄 CreateOrderUseCase.ts
│   ├── 📄 ProcessPaymentUseCase.ts
│   └── 📄 CancelOrderUseCase.ts
└── 📂 ports/
    ├── 📄 PaymentProcessingPort.ts
    └── 📄 InventoryManagementPort.ts
```

#### 💡 **Tip Visual**:

```
⚡ APPLICATION = Casos de uso específicos
├── 🎭 Use Cases = "Quiero crear una orden"
└── 🔌 Ports = Interfaces hacia afuera
```

#### ✅ **Resultado**: Application layer completo

---

### **📋 Paso 2.3: Order Management - Infrastructure** (10 min)

#### 🎯 **Objetivo**: Crear adaptadores externos

#### 🔧 **Acciones**:

1. Crear `src/order-management/infrastructure/`
2. Crear subcarpetas: `repositories/`, `external-services/`
3. Crear Factory del bounded context

#### 📁 **Estructura esperada**:

```
src/order-management/infrastructure/
├── 📂 repositories/
│   └── 📄 PostgreSQLOrderRepository.ts
├── 📂 external-services/
│   └── 📄 StripePaymentService.ts
└── 📄 OrderManagementFactory.ts
```

#### 💡 **Tip Visual**:

```
🔌 INFRASTRUCTURE = Adaptadores al mundo real
├── 🗄️ Repositories = Implementaciones de BD
├── 🌐 External Services = APIs externas
└── 🏭 Factory = Ensambla todo el context
```

#### ✅ **Resultado**: Infrastructure layer completo

---

## 🟩 **FASE 3: Conexión Base de Datos** (20 min)

### **📋 Paso 3.1: Database Shared** (10 min)

#### 🎯 **Objetivo**: Crear conexión compartida

#### 🔧 **Acciones**:

1. Crear `shared/database/`
2. Implementar connection pool
3. Configurar variables de entorno

#### 📁 **Estructura esperada**:

```
shared/database/
├── 📄 connection.ts
└── 📄 migrations/ (carpeta)
```

#### 💡 **Tip Visual**:

```
🔄 SHARED = Recursos compartidos
└── 🔌 Database = Un pool para todos
    ├── 🏪 Order Context usa el pool
    └── 👥 User Context usa el MISMO pool
```

#### ✅ **Resultado**: Pool de conexiones funcionando

---

### **📋 Paso 3.2: Primer Repositorio Real** (10 min)

#### 🎯 **Objetivo**: Conectar Order Repository a la BD

#### 🔧 **Acciones**:

1. Implementar `PostgreSQLOrderRepository`
2. Conectar con el pool compartido
3. Crear métodos básicos (save, findById)

#### 💡 **Tip Visual**:

```
🔄 Flujo de Datos:
Use Case → Repository Interface → PostgreSQL Implementation → Pool → Database
```

#### ✅ **Resultado**: Primer repositorio conectado a BD

---

## 🟪 **FASE 4: Web Entrypoint** (25 min)

### **📋 Paso 4.1: Estructura Web** (5 min)

#### 🎯 **Objetivo**: Crear estructura del entrypoint web

#### 🔧 **Acciones**:

1. Crear `entrypoints/web/`
2. Crear subcarpetas: `controllers/`, `routes/`
3. Crear archivos base

#### 📁 **Estructura esperada**:

```
entrypoints/web/
├── 📂 controllers/
│   └── 📄 OrderController.ts
├── 📂 routes/
│   └── 📄 orderRoutes.ts
├── 📄 app.ts
└── 📄 server.ts
```

#### ✅ **Resultado**: Estructura web lista

---

### **📋 Paso 4.2: Order Controller** (10 min)

#### 🎯 **Objetivo**: Crear controlador para órdenes

#### 🔧 **Acciones**:

1. Implementar `OrderController`
2. Métodos: createOrder, getOrder, processPayment, cancelOrder
3. Usar factory pattern para dependencias

#### 💡 **Tip Visual**:

```
🌐 HTTP Request
    ↓
🎮 Controller (traduce HTTP ↔ Domain)
    ↓
🏭 Factory (crea use cases)
    ↓
⚡ Use Case (lógica de aplicación)
    ↓
🗄️ Repository (persiste datos)
```

#### ✅ **Resultado**: Controller funcionando

---

### **📋 Paso 4.3: Express App** (10 min)

#### 🎯 **Objetivo**: Configurar Express con dependency injection

#### 🔧 **Acciones**:

1. Crear `app.ts` con configuración Express
2. Implementar dependency injection manual
3. Conectar rutas con controllers

#### 💡 **Tip Visual**:

```
🚀 Server Start
    ↓
🔌 Create Database Pool
    ↓
🏭 Create Factories (inject pool)
    ↓
🎮 Create Controllers (inject factories)
    ↓
🛤️ Setup Routes (inject controllers)
    ↓
📱 Express App Ready
```

#### ✅ **Resultado**: API REST funcionando

---

## 🟩 **FASE 5: Segundo Bounded Context** (20 min)

### **📋 Paso 5.1: User Management Structure** (10 min)

#### 🎯 **Objetivo**: Crear User Management siguiendo el mismo patrón

#### 🔧 **Acciones**:

1. Copiar estructura de Order Management
2. Adaptar para User domain
3. Crear Factory correspondiente

#### 📁 **Estructura esperada**:

```
src/user-management/
├── 📂 domain/
├── 📂 application/
└── 📂 infrastructure/
    └── 📄 UserManagementFactory.ts
```

#### 💡 **Tip Visual**:

```
🏪 Order Management        👥 User Management
├── 🎯 domain/            ├── 🎯 domain/
├── ⚡ application/       ├── ⚡ application/
└── 🔌 infrastructure/    └── 🔌 infrastructure/

📋 Mismo patrón, diferente dominio
```

#### ✅ **Resultado**: Segundo bounded context estructurado

---

### **📋 Paso 5.2: User Web Integration** (10 min)

#### 🎯 **Objetivo**: Integrar User Management con web entrypoint

#### 🔧 **Acciones**:

1. Crear `UserController`
2. Crear `userRoutes`
3. Integrar en `app.ts`

#### 💡 **Tip Visual**:

```
📱 Express App
├── 🛤️ /api/orders/* → OrderController → OrderFactory
└── 🛤️ /api/users/* → UserController → UserFactory

🔄 Cada controller usa su factory independiente
```

#### ✅ **Resultado**: API completa con dos bounded contexts

---

## 🟥 **FASE 6: Testing y Refinamiento** (20 min)

### **📋 Paso 6.1: Testing Básico** (10 min)

#### 🎯 **Objetivo**: Crear tests para validar funcionamiento

#### 🔧 **Acciones**:

1. Configurar Jest
2. Test de domain entities
3. Test de use cases
4. Test de API endpoints

#### 📁 **Estructura esperada**:

```
tests/
├── 📂 unit/
│   ├── 📂 order-management/
│   └── 📂 user-management/
├── 📂 integration/
└── 📂 e2e/
```

#### ✅ **Resultado**: Tests básicos funcionando

---

### **📋 Paso 6.2: Documentación y Scripts** (10 min)

#### 🎯 **Objetivo**: Documentar y facilitar uso

#### 🔧 **Acciones**:

1. Crear README.md completo
2. Configurar scripts de npm
3. Crear documentación de API
4. Setup de development workflow

#### 📁 **Estructura final**:

```
mi-app/
├── 📂 src/
│   ├── 📂 order-management/
│   └── 📂 user-management/
├── 📂 entrypoints/
│   └── 📂 web/
├── 📂 shared/
├── 📂 tests/
├── 📂 docs/
├── 📄 README.md
└── 📄 package.json
```

#### ✅ **Resultado**: Proyecto completo y documentado

---

## 🎉 **Resultado Final**

### **✅ Lo que has logrado**:

1. **🏗️ Arquitectura Screaming**: Los nombres de carpeta gritan el propósito
2. **🔄 Hexagonal Architecture**: Separación clara de capas
3. **📦 Bounded Contexts**: Cada dominio encapsulado
4. **🔌 Infrastructure Independiente**: Cada context maneja su infra
5. **🚪 Multiple Entrypoints**: Preparado para web, CLI, messaging
6. **🔄 Shared Resources**: Eficiencia con recursos compartidos
7. **🧪 Testeable**: Estructura que facilita testing
8. **📈 Escalable**: Fácil agregar nuevos bounded contexts

### **🚀 Próximos pasos sugeridos**:

1. **📨 Agregar Events**: Para comunicación entre contexts
2. **💻 CLI Entrypoint**: Para operaciones administrativas
3. **🐳 Dockerizar**: Para deployment fácil
4. **📊 Monitoring**: Logs, métricas, health checks
5. **🔒 Security**: Autenticación, autorización
6. **📱 Frontend**: React/Vue que consuma la API

### **🎯 Conceptos clave aprendidos**:

- **Screaming Architecture**: La estructura debe gritar el negocio
- **Bounded Contexts**: Encapsulación por dominio
- **Dependency Inversion**: Infrastructure depende de Domain
- **Factory Pattern**: Ensamblaje de dependencias
- **Shared Resources**: Eficiencia sin acoplamiento
- **Iterative Development**: Construcción paso a paso

---

## 📚 **Recursos Adicionales**

- **📖 Domain-Driven Design** (Eric Evans)
- **🏛️ Clean Architecture** (Robert Martin)
- **📐 Hexagonal Architecture** (Alistair Cockburn)
- **🔄 Event Storming** para descubrir bounded contexts

---

\*\*🎊 ¡Felicitaciones! Has construido una arquitectura robusta, escalable y
