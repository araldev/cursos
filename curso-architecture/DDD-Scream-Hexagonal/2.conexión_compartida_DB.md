# 🔌 Conexión Compartida - Explicación Didáctica

> Te explico de manera simple cómo funciona la conexión compartida:

# 🏠 Analogía: Casa con Servicios Compartidos

> Imagina que tienes una casa grande con varios departamentos (bounded contexts):

```plaintext
🏠 CASA (Aplicación)
├── 🏪 Departamento "Tienda" (order-management)
├── 👥 Departamento "Usuarios" (user-management)
└── 🔌 Servicios Compartidos (shared)
    ├── 💡 Electricidad (Database Connection)
    ├── 💧 Agua (Config)
    └── 🌐 Internet (Logging)
```

# ⚡ ¿Cómo Funciona la Electricidad (DB Connection)?

## ❌ MALO: Cada departamento su propio medidor

```plaintext
🏪 Tienda → 🔌 Medidor A → ⚡ Red Eléctrica
👥 Usuarios → 🔌 Medidor B → ⚡ Red Eléctrica
```

### Problemas:

- Costoso (más medidores)
- Ineficiente (múltiples conexiones)
- Difícil mantenimiento

## ✅ BUENO: Un solo medidor, múltiples enchufes

```plaintext
🏠 Casa → 🔌 Medidor Principal → ⚡ Red Eléctrica
     ├── 🏪 Tienda (usa enchufes)
     └── 👥 Usuarios (usa enchufes)
```

### Ventajas:

- Un solo punto de conexión
- Eficiencia compartida
- Fácil mantenimiento

## 🔄 En Términos de Base de Datos

### 🔌 Connection Pool = Medidor Principal

```js
// UN SOLO POOL para toda la aplicación
const pool = new Pool({
  host: "database-server",
  max: 20, // máximo 20 conexiones simultáneas
});
```

### 🏪 Cada Bounded Context = Departamento

```js
// Order Management "usa" el pool
class OrderRepository {
  constructor(pool) {
    this.pool = pool; // Recibe el pool compartido
  }

  async save(order) {
    const client = await this.pool.connect(); // "Enchufa"
    // Hacer queries...
    client.release(); // "Desenchufa"
  }
}

// User Management también "usa" el mismo pool
class UserRepository {
  constructor(pool) {
    this.pool = pool; // El MISMO pool
  }
}
```

### 🎯 Flujo Simple

1. Inicio de la Aplicación 🚀

```plaintext
server.ts:
  1. Crear 1 pool de conexiones
  2. Pasarlo a cada bounded context
  3. Cada context lo usa para sus repositorios
```

2. Cuando llega una Request 📨

```plaintext
HTTP Request → OrderController
    ↓
OrderUseCase → OrderRepository
    ↓
repository.pool.connect()  ← "Pide una conexión"
    ↓
Ejecuta SQL
    ↓
client.release()  ← "Devuelve la conexión"
```

## 🔄 ¿Por qué Compartir la Conexión?

### 💰 Eficiencia

- 20 conexiones para TODA la app
- En lugar de 20 × 2 contexts = 40 conexiones

### ⚡ Performance

- Pool reutiliza conexiones existentes
- No crear/destruir conexiones constantemente

### 🎛️ Control Centralizado

- Una sola configuración de DB
- Fácil cambiar host, credentials, etc.

### 📊 Monitoring

- Ver todas las conexiones en un lugar
- Detectar problemas fácilmente

## 🏗️ En la Práctica

**Paso 1:** Crear Pool (Una vez)

```js
// Al inicio de la app
const sharedPool = createDatabasePool();
```

**Paso 2:** Inyectar en Factories

```js
// Cada bounded context recibe el mismo pool
const orderFactory = new OrderFactory(sharedPool);
const userFactory = new UserFactory(sharedPool);
```

**Paso 3:** Usar en Repositories

```js
// Dentro de cada repository
const connection = await this.pool.connect();
// Hacer query
connection.release();
```

## 🤔 ¿Y la Independencia de Bounded Contexts?

###✅ SÍ son independientes en:

- Lógica de negocio (domain/application)
- Schemas de tablas (orders vs users tables)
- Queries específicas (cada uno sus SQLs)
- Evolución (cambiar OrderRepository sin afectar UserRepository)

### 🔄 Solo comparten:

- La tubería (connection pool)
- La configuración (host, port, credentials)

### 🎨 Analogía Final: Restaurante

```plaintext
🍽️ RESTAURANTE (Aplicación)
├── 👨‍🍳 Cocina (order-management)
├── 🧑‍💼 Meseros (user-management)
└── 🔧 Servicios Compartidos
    ├── 💡 Luz (DB Connection)
    ├── 🔥 Gas (Config)
    └── 💧 Agua (Logging)
```

- Cocina y Meseros tienen trabajos completamente diferentes
- Pero ambos usan la misma electricidad, gas, agua
- Eficiente: No necesitas 2 medidores de luz
- Independientes: Cocina puede cambiar sus procesos sin afectar a Meseros
