# üèóÔ∏è Tutorial: Screaming + Hexagonal Architecture

## Con Infrastructure por Bounded Context

### üìö √çndice

1. [Preparaci√≥n del Proyecto](#1-preparaci√≥n-del-proyecto)
2. [Estructura Base](#2-estructura-base)
3. [Shared Infrastructure](#3-shared-infrastructure)
4. [Primer Bounded Context: User Management](#4-primer-bounded-context-user-management)
5. [Segundo Bounded Context: Order Management](#5-segundo-bounded-context-order-management)
6. [Entrypoints Web](#6-entrypoints-web)
7. [Testing](#7-testing)
8. [Extensiones y Mejoras](#8-extensiones-y-mejoras)

---

## 1. Preparaci√≥n del Proyecto

### üöÄ Inicializar Proyecto

```bash
mkdir screaming-hex-architecture
cd screaming-hex-architecture
npm init -y
```

### üì¶ Instalar Dependencias

```bash
# Dependencias principales
npm install express cors pg dotenv

# DevDependencies
npm install -D typescript @types/node @types/express @types/pg ts-node nodemon

# Testing (opcional para el final)
npm install -D jest @types/jest ts-jest
```

### ‚öôÔ∏è Configuraci√≥n TypeScript

Crear `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*", "entrypoints/**/*", "shared/**/*", "config/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### üìã Package.json Scripts

Actualizar `package.json`:

```json
{
  "scripts": {
    "dev": "nodemon --exec ts-node entrypoints/web/server.ts",
    "build": "tsc",
    "start": "node dist/entrypoints/web/server.js",
    "test": "jest",
    "test:watch": "jest --watch"
  }
}
```

---

## 2. Estructura Base

### üìÅ Crear Directorios

```bash
mkdir -p src/{user-management,order-management}
mkdir -p src/user-management/{domain,application,infrastructure}
mkdir -p src/order-management/{domain,application,infrastructure}
mkdir -p entrypoints/{web,cli,messaging}
mkdir -p shared/{database,config,utils}
mkdir -p config
mkdir -p tests/{unit,integration,e2e}
```

### üéØ Verificar Estructura

```
proyecto/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ user-management/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îî‚îÄ‚îÄ order-management/
‚îÇ       ‚îú‚îÄ‚îÄ domain/
‚îÇ       ‚îú‚îÄ‚îÄ application/
‚îÇ       ‚îî‚îÄ‚îÄ infrastructure/
‚îú‚îÄ‚îÄ entrypoints/
‚îÇ   ‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îî‚îÄ‚îÄ messaging/
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ config/
‚îî‚îÄ‚îÄ tests/
```

---

## 3. Shared Infrastructure

### üîß Variables de Entorno

Crear `.env`:

```env
# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=screaming_arch_db
DB_USER=postgres
DB_PASSWORD=your_password

# Application
NODE_ENV=development
PORT=3000

# External Services
STRIPE_SECRET_KEY=sk_test_...
SENDGRID_API_KEY=SG...
```

### üîå Database Connection

Crear `shared/database/connection.ts`:

```typescript
import { Pool } from "pg";

export class DatabaseConnection {
  private static instance: Pool;

  static getInstance(): Pool {
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new Pool({
        host: process.env.DB_HOST || "localhost",
        port: parseInt(process.env.DB_PORT || "5432"),
        database: process.env.DB_NAME || "screaming_arch_db",
        user: process.env.DB_USER || "postgres",
        password: process.env.DB_PASSWORD || "password",
        max: 20, // pool size
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 2000,
      });

      // Manejo de errores del pool
      DatabaseConnection.instance.on("error", (err) => {
        console.error("Unexpected error on idle client", err);
      });
    }
    return DatabaseConnection.instance;
  }

  static async close(): Promise<void> {
    if (DatabaseConnection.instance) {
      await DatabaseConnection.instance.end();
    }
  }

  // M√©todo para testing
  static async testConnection(): Promise<boolean> {
    try {
      const pool = DatabaseConnection.getInstance();
      await pool.query("SELECT NOW()");
      return true;
    } catch (error) {
      console.error("Database connection failed:", error);
      return false;
    }
  }
}
```

### ‚öôÔ∏è Configuraci√≥n Global

Crear `shared/config/index.ts`:

```typescript
import dotenv from "dotenv";

dotenv.config();

export const config = {
  database: {
    host: process.env.DB_HOST || "localhost",
    port: parseInt(process.env.DB_PORT || "5432"),
    name: process.env.DB_NAME || "screaming_arch_db",
    user: process.env.DB_USER || "postgres",
    password: process.env.DB_PASSWORD || "password",
  },
  app: {
    port: parseInt(process.env.PORT || "3000"),
    env: process.env.NODE_ENV || "development",
  },
  services: {
    stripe: {
      secretKey: process.env.STRIPE_SECRET_KEY || "",
    },
    sendgrid: {
      apiKey: process.env.SENDGRID_API_KEY || "",
    },
  },
};
```

---

## 4. Primer Bounded Context: User Management

### üéØ Domain Layer

#### Value Objects

Crear `src/user-management/domain/value-objects/UserId.ts`:

```typescript
export class UserId {
  private constructor(private readonly value: string) {
    this.validate(value);
  }

  private validate(value: string): void {
    if (!value || value.trim().length === 0) {
      throw new Error("UserId cannot be empty");
    }
    if (!/^[a-zA-Z0-9-_]+$/.test(value)) {
      throw new Error(
        "UserId must contain only alphanumeric characters, hyphens, and underscores"
      );
    }
  }

  static generate(): UserId {
    const id =
      "user_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
    return new UserId(id);
  }

  static fromString(value: string): UserId {
    return new UserId(value);
  }

  toString(): string {
    return this.value;
  }

  equals(other: UserId): boolean {
    return this.value === other.value;
  }
}
```

Crear `src/user-management/domain/value-objects/Email.ts`:

```typescript
export class Email {
  private constructor(private readonly value: string) {
    this.validate(value);
  }

  private validate(value: string): void {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      throw new Error("Invalid email format");
    }
  }

  static fromString(value: string): Email {
    return new Email(value.toLowerCase().trim());
  }

  toString(): string {
    return this.value;
  }

  getDomain(): string {
    return this.value.split("@")[1];
  }

  equals(other: Email): boolean {
    return this.value === other.value;
  }
}
```

#### Entities

Crear `src/user-management/domain/entities/User.ts`:

```typescript
import { UserId } from "../value-objects/UserId";
import { Email } from "../value-objects/Email";

export class User {
  private constructor(
    private id: UserId,
    private email: Email,
    private firstName: string,
    private lastName: string,
    private createdAt: Date,
    private updatedAt: Date = new Date()
  ) {}

  // Factory method para crear nuevo usuario
  static create(email: Email, firstName: string, lastName: string): User {
    return new User(UserId.generate(), email, firstName, lastName, new Date());
  }

  // Factory method para reconstruir desde persistencia
  static fromPersistence(data: {
    id: UserId;
    email: Email;
    firstName: string;
    lastName: string;
    createdAt: Date;
    updatedAt?: Date;
  }): User {
    return new User(
      data.id,
      data.email,
      data.firstName,
      data.lastName,
      data.createdAt,
      data.updatedAt || new Date()
    );
  }

  // Getters
  getId(): UserId {
    return this.id;
  }
  getEmail(): Email {
    return this.email;
  }
  getFirstName(): string {
    return this.firstName;
  }
  getLastName(): string {
    return this.lastName;
  }
  getCreatedAt(): Date {
    return this.createdAt;
  }
  getUpdatedAt(): Date {
    return this.updatedAt;
  }

  // M√©todos de negocio
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }

  updateProfile(firstName: string, lastName: string): void {
    this.firstName = firstName;
    this.lastName = lastName;
    this.updatedAt = new Date();
  }

  changeEmail(newEmail: Email): void {
    this.email = newEmail;
    this.updatedAt = new Date();
  }

  // Reglas de negocio
  canReceiveNotifications(): boolean {
    // Ejemplo: usuarios con emails de dominios espec√≠ficos no reciben notificaciones
    const restrictedDomains = ["spam.com", "fake.com"];
    return !restrictedDomains.includes(this.email.getDomain());
  }
}
```

#### Repository Interface

Crear `src/user-management/domain/repositories/UserRepository.ts`:

```typescript
import { User } from "../entities/User";
import { UserId } from "../value-objects/UserId";
import { Email } from "../value-objects/Email";

export interface UserRepository {
  save(user: User): Promise<void>;
  findById(id: UserId): Promise<User | null>;
  findByEmail(email: Email): Promise<User | null>;
  findAll(): Promise<User[]>;
  delete(id: UserId): Promise<void>;
  existsByEmail(email: Email): Promise<boolean>;
}
```

### ‚ö° Application Layer

#### Use Cases

Crear `src/user-management/application/use-cases/CreateUserUseCase.ts`:

```typescript
import { User } from "../../domain/entities/User";
import { Email } from "../../domain/value-objects/Email";
import { UserRepository } from "../../domain/repositories/UserRepository";

export class CreateUserRequest {
  constructor(
    public readonly email: string,
    public readonly firstName: string,
    public readonly lastName: string
  ) {}
}

export class CreateUserResponse {
  constructor(
    public readonly userId: string,
    public readonly email: string,
    public readonly fullName: string
  ) {}
}

export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(request: CreateUserRequest): Promise<CreateUserResponse> {
    // Validar entrada
    this.validateRequest(request);

    const email = Email.fromString(request.email);

    // Verificar que el email no exista
    const existingUser = await this.userRepository.findByEmail(email);
    if (existingUser) {
      throw new Error(`User with email ${request.email} already exists`);
    }

    // Crear usuario
    const user = User.create(email, request.firstName, request.lastName);

    // Guardar
    await this.userRepository.save(user);

    return new CreateUserResponse(
      user.getId().toString(),
      user.getEmail().toString(),
      user.getFullName()
    );
  }

  private validateRequest(request: CreateUserRequest): void {
    if (!request.firstName?.trim()) {
      throw new Error("First name is required");
    }
    if (!request.lastName?.trim()) {
      throw new Error("Last name is required");
    }
    if (!request.email?.trim()) {
      throw new Error("Email is required");
    }
  }
}
```

### üîå Infrastructure Layer

#### Repository Implementation

Crear `src/user-management/infrastructure/repositories/PostgreSQLUserRepository.ts`:

```typescript
import { Pool } from "pg";
import { UserRepository } from "../../domain/repositories/UserRepository";
import { User } from "../../domain/entities/User";
import { UserId } from "../../domain/value-objects/UserId";
import { Email } from "../../domain/value-objects/Email";

export class PostgreSQLUserRepository implements UserRepository {
  constructor(private db: Pool) {}

  async save(user: User): Promise<void> {
    await this.db.query(
      `
      INSERT INTO users (id, email, first_name, last_name, created_at, updated_at)
      VALUES ($1, $2, $3, $4, $5, $6)
      ON CONFLICT (id) DO UPDATE SET
        email = EXCLUDED.email,
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        updated_at = EXCLUDED.updated_at
    `,
      [
        user.getId().toString(),
        user.getEmail().toString(),
        user.getFirstName(),
        user.getLastName(),
        user.getCreatedAt(),
        user.getUpdatedAt(),
      ]
    );
  }

  async findById(id: UserId): Promise<User | null> {
    const result = await this.db.query(
      `
      SELECT * FROM users WHERE id = $1
    `,
      [id.toString()]
    );

    if (result.rows.length === 0) return null;

    return this.mapToUser(result.rows[0]);
  }

  async findByEmail(email: Email): Promise<User | null> {
    const result = await this.db.query(
      `
      SELECT * FROM users WHERE email = $1
    `,
      [email.toString()]
    );

    if (result.rows.length === 0) return null;

    return this.mapToUser(result.rows[0]);
  }

  async findAll(): Promise<User[]> {
    const result = await this.db.query(`
      SELECT * FROM users ORDER BY created_at DESC
    `);

    return result.rows.map((row) => this.mapToUser(row));
  }

  async delete(id: UserId): Promise<void> {
    await this.db.query(
      `
      DELETE FROM users WHERE id = $1
    `,
      [id.toString()]
    );
  }

  async existsByEmail(email: Email): Promise<boolean> {
    const result = await this.db.query(
      `
      SELECT 1 FROM users WHERE email = $1 LIMIT 1
    `,
      [email.toString()]
    );

    return result.rows.length > 0;
  }

  private mapToUser(row: any): User {
    return User.fromPersistence({
      id: UserId.fromString(row.id),
      email: Email.fromString(row.email),
      firstName: row.first_name,
      lastName: row.last_name,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }
}
```

#### Factory

Crear `src/user-management/infrastructure/UserManagementFactory.ts`:

```typescript
import { Pool } from "pg";
import { PostgreSQLUserRepository } from "./repositories/PostgreSQLUserRepository";
import { CreateUserUseCase } from "../application/use-cases/CreateUserUseCase";

export class UserManagementFactory {
  private userRepository: PostgreSQLUserRepository;

  constructor(private database: Pool) {
    this.setupInfrastructure();
  }

  private setupInfrastructure(): void {
    this.userRepository = new PostgreSQLUserRepository(this.database);
  }

  // Use Cases
  createUserUseCase(): CreateUserUseCase {
    return new CreateUserUseCase(this.userRepository);
  }

  // Repository access (para otros bounded contexts si necesario)
  getUserRepository(): PostgreSQLUserRepository {
    return this.userRepository;
  }
}
```

---

## 5. Segundo Bounded Context: Order Management

### üéØ Domain Layer

#### Value Objects

Crear `src/order-management/domain/value-objects/OrderId.ts`:

```typescript
export class OrderId {
  private constructor(private readonly value: string) {
    this.validate(value);
  }

  private validate(value: string): void {
    if (!value || value.trim().length === 0) {
      throw new Error("OrderId cannot be empty");
    }
  }

  static generate(): OrderId {
    const timestamp =
      new Date().getFullYear().toString().substr(-2) +
      String(Date.now()).substr(-8);
    const random = Math.random().toString(36).substr(2, 4).toUpperCase();
    const id = `ORD-${timestamp}-${random}`;
    return new OrderId(id);
  }

  static fromString(value: string): OrderId {
    return new OrderId(value);
  }

  toString(): string {
    return this.value;
  }

  equals(other: OrderId): boolean {
    return this.value === other.value;
  }
}
```

Crear `src/order-management/domain/value-objects/Money.ts`:

```typescript
export class Money {
  private constructor(
    private readonly amount: number,
    private readonly currency: string
  ) {
    this.validate(amount, currency);
  }

  private validate(amount: number, currency: string): void {
    if (amount < 0) {
      throw new Error("Amount cannot be negative");
    }
    if (!currency || currency.length !== 3) {
      throw new Error("Currency must be a 3-letter code");
    }
  }

  static fromAmount(amount: number, currency: string = "USD"): Money {
    return new Money(amount, currency.toUpperCase());
  }

  static zero(currency: string = "USD"): Money {
    return new Money(0, currency.toUpperCase());
  }

  getAmount(): number {
    return this.amount;
  }
  getCurrency(): string {
    return this.currency;
  }

  add(other: Money): Money {
    this.ensureSameCurrency(other);
    return new Money(this.amount + other.amount, this.currency);
  }

  subtract(other: Money): Money {
    this.ensureSameCurrency(other);
    return new Money(this.amount - other.amount, this.currency);
  }

  multiply(factor: number): Money {
    return new Money(this.amount * factor, this.currency);
  }

  equals(other: Money): boolean {
    return this.amount === other.amount && this.currency === other.currency;
  }

  isGreaterThan(other: Money): boolean {
    this.ensureSameCurrency(other);
    return this.amount > other.amount;
  }

  toString(): string {
    return `${this.amount.toFixed(2)} ${this.currency}`;
  }

  private ensureSameCurrency(other: Money): void {
    if (this.currency !== other.currency) {
      throw new Error(
        `Cannot operate with different currencies: ${this.currency} vs ${other.currency}`
      );
    }
  }
}
```

Crear `src/order-management/domain/value-objects/OrderStatus.ts`:

```typescript
export enum OrderStatus {
  PENDING = "PENDING",
  CONFIRMED = "CONFIRMED",
  PAID = "PAID",
  SHIPPED = "SHIPPED",
  DELIVERED = "DELIVERED",
  CANCELLED = "CANCELLED",
}

export class OrderStatusValue {
  private constructor(private readonly status: OrderStatus) {}

  static fromString(status: string): OrderStatusValue {
    const upperStatus = status.toUpperCase();
    if (!Object.values(OrderStatus).includes(upperStatus as OrderStatus)) {
      throw new Error(`Invalid order status: ${status}`);
    }
    return new OrderStatusValue(upperStatus as OrderStatus);
  }

  static pending(): OrderStatusValue {
    return new OrderStatusValue(OrderStatus.PENDING);
  }

  static confirmed(): OrderStatusValue {
    return new OrderStatusValue(OrderStatus.CONFIRMED);
  }

  getValue(): OrderStatus {
    return this.status;
  }

  toString(): string {
    return this.status;
  }

  isPending(): boolean {
    return this.status === OrderStatus.PENDING;
  }
  isConfirmed(): boolean {
    return this.status === OrderStatus.CONFIRMED;
  }
  isPaid(): boolean {
    return this.status === OrderStatus.PAID;
  }
  isShipped(): boolean {
    return this.status === OrderStatus.SHIPPED;
  }
  isDelivered(): boolean {
    return this.status === OrderStatus.DELIVERED;
  }
  isCancelled(): boolean {
    return this.status === OrderStatus.CANCELLED;
  }

  canTransitionTo(newStatus: OrderStatusValue): boolean {
    const transitions: Record<OrderStatus, OrderStatus[]> = {
      [OrderStatus.PENDING]: [OrderStatus.CONFIRMED, OrderStatus.CANCELLED],
      [OrderStatus.CONFIRMED]: [OrderStatus.PAID, OrderStatus.CANCELLED],
      [OrderStatus.PAID]: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
      [OrderStatus.SHIPPED]: [OrderStatus.DELIVERED],
      [OrderStatus.DELIVERED]: [],
      [OrderStatus.CANCELLED]: [],
    };

    return transitions[this.status].includes(newStatus.getValue());
  }
}
```

#### Entities

Crear `src/order-management/domain/entities/OrderItem.ts`:

```typescript
import { Money } from "../value-objects/Money";

export class OrderItem {
  private constructor(
    private productId: string,
    private quantity: number,
    private unitPrice: Money
  ) {
    this.validate();
  }

  static create(
    productId: string,
    quantity: number,
    unitPrice: Money
  ): OrderItem {
    return new OrderItem(productId, quantity, unitPrice);
  }

  private validate(): void {
    if (!this.productId?.trim()) {
      throw new Error("Product ID is required");
    }
    if (this.quantity <= 0) {
      throw new Error("Quantity must be positive");
    }
  }

  getProductId(): string {
    return this.productId;
  }
  getQuantity(): number {
    return this.quantity;
  }
  getUnitPrice(): Money {
    return this.unitPrice;
  }

  getSubtotal(): Money {
    return this.unitPrice.multiply(this.quantity);
  }

  changeQuantity(newQuantity: number): void {
    if (newQuantity <= 0) {
      throw new Error("Quantity must be positive");
    }
    this.quantity = newQuantity;
  }

  updatePrice(newPrice: Money): void {
    this.unitPrice = newPrice;
  }
}
```

Crear `src/order-management/domain/entities/Order.ts`:

```typescript
import { OrderId } from "../value-objects/OrderId";
import { Money } from "../value-objects/Money";
import { OrderStatusValue, OrderStatus } from "../value-objects/OrderStatus";
import { OrderItem } from "./OrderItem";

export class Order {
  private constructor(
    private id: OrderId,
    private userId: string,
    private items: OrderItem[],
    private status: OrderStatusValue,
    private createdAt: Date,
    private updatedAt: Date = new Date()
  ) {}

  static create(userId: string, items: OrderItem[]): Order {
    if (!userId?.trim()) {
      throw new Error("User ID is required");
    }
    if (!items || items.length === 0) {
      throw new Error("Order must have at least one item");
    }

    return new Order(
      OrderId.generate(),
      userId,
      [...items], // defensive copy
      OrderStatusValue.pending(),
      new Date()
    );
  }

  static fromPersistence(data: {
    id: OrderId;
    userId: string;
    items: OrderItem[];
    status: string;
    createdAt: Date;
    updatedAt?: Date;
  }): Order {
    return new Order(
      data.id,
      data.userId,
      data.items,
      OrderStatusValue.fromString(data.status),
      data.createdAt,
      data.updatedAt || new Date()
    );
  }

  // Getters
  getId(): OrderId {
    return this.id;
  }
  getUserId(): string {
    return this.userId;
  }
  getItems(): OrderItem[] {
    return [...this.items];
  } // defensive copy
  getStatus(): OrderStatusValue {
    return this.status;
  }
  getCreatedAt(): Date {
    return this.createdAt;
  }
  getUpdatedAt(): Date {
    return this.updatedAt;
  }

  // Calculated properties
  getTotal(): Money {
    if (this.items.length === 0) {
      return Money.zero();
    }

    return this.items
      .map((item) => item.getSubtotal())
      .reduce((total, subtotal) => total.add(subtotal));
  }

  getItemCount(): number {
    return this.items.reduce((total, item) => total + item.getQuantity(), 0);
  }

  // Business methods
  addItem(item: OrderItem): void {
    if (!this.canBeModified()) {
      throw new Error("Cannot modify order in current status");
    }

    // Check if product already exists
    const existingItemIndex = this.items.findIndex(
      (existing) => existing.getProductId() === item.getProductId()
    );

    if (existingItemIndex >= 0) {
      // Update quantity
      const existingItem = this.items[existingItemIndex];
      existingItem.changeQuantity(
        existingItem.getQuantity() + item.getQuantity()
      );
    } else {
      // Add new item
      this.items.push(item);
    }

    this.updatedAt = new Date();
  }

  removeItem(productId: string): void {
    if (!this.canBeModified()) {
      throw new Error("Cannot modify order in current status");
    }

    this.items = this.items.filter((item) => item.getProductId() !== productId);
    this.updatedAt = new Date();
  }

  confirm(): void {
    this.changeStatus(OrderStatusValue.confirmed());
  }

  markAsPaid(): void {
    this.changeStatus(OrderStatusValue.fromString(OrderStatus.PAID));
  }

  ship(): void {
    this.changeStatus(OrderStatusValue.fromString(OrderStatus.SHIPPED));
  }

  deliver(): void {
    this.changeStatus(OrderStatusValue.fromString(OrderStatus.DELIVERED));
  }

  cancel(): void {
    if (this.status.isDelivered()) {
      throw new Error("Cannot cancel delivered order");
    }
    this.changeStatus(OrderStatusValue.fromString(OrderStatus.CANCELLED));
  }

  // Business rules
  canBeModified(): boolean {
    return this.status.isPending();
  }

  canBePaid(): boolean {
    return this.status.isConfirmed();
  }

  canBeCancelled(): boolean {
    return !this.status.isDelivered() && !this.status.isCancelled();
  }

  private changeStatus(newStatus: OrderStatusValue): void {
    if (!this.status.canTransitionTo(newStatus)) {
      throw new Error(`Cannot transition from ${this.status} to ${newStatus}`);
    }

    this.status = newStatus;
    this.updatedAt = new Date();
  }
}
```

#### Repository Interface

Crear `src/order-management/domain/repositories/OrderRepository.ts`:

```typescript
import { Order } from "../entities/Order";
import { OrderId } from "../value-objects/OrderId";
import { OrderStatusValue } from "../value-objects/OrderStatus";

export interface OrderRepository {
  save(order: Order): Promise<void>;
  findById(id: OrderId): Promise<Order | null>;
  findByUserId(userId: string): Promise<Order[]>;
  findByStatus(status: OrderStatusValue): Promise<Order[]>;
  findAll(): Promise<Order[]>;
  delete(id: OrderId): Promise<void>;
}
```

### ‚ö° Application Layer

Crear `src/order-management/application/use-cases/CreateOrderUseCase.ts`:

```typescript
import { Order } from "../../domain/entities/Order";
import { OrderItem } from "../../domain/entities/OrderItem";
import { Money } from "../../domain/value-objects/Money";
import { OrderRepository } from "../../domain/repositories/OrderRepository";

export class CreateOrderRequest {
  constructor(
    public readonly userId: string,
    public readonly items: Array<{
      productId: string;
      quantity: number;
      unitPrice: number;
      currency?: string;
    }>
  ) {}
}

export class CreateOrderResponse {
  constructor(
    public readonly orderId: string,
    public readonly userId: string,
    public readonly total: string,
    public readonly status: string
  ) {}
}

export class CreateOrderUseCase {
  constructor(private orderRepository: OrderRepository) {}

  async execute(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    // Validar entrada
    this.validateRequest(request);

    // Crear items del dominio
    const orderItems = request.items.map((item) =>
      OrderItem.create(
        item.productId,
        item.quantity,
        Money.fromAmount(item.unitPrice, item.currency || "USD")
      )
    );

    // Crear orden
    const order = Order.create(request.userId, orderItems);

    // Guardar
    await this.orderRepository.save(order);

    return new CreateOrderResponse(
      order.getId().toString(),
      order.getUserId(),
      order.getTotal().toString(),
      order.getStatus().toString()
    );
  }

  private validateRequest(request: CreateOrderRequest): void {
    if (!request.userId?.trim()) {
      throw new Error("User ID is required");
    }

    if (!request.items || request.items.length === 0) {
      throw new Error("Order must have at least one item");
    }

    request.items.forEach((item, index) => {
      if (!item.productId?.trim()) {
        throw new Error(`Item ${index + 1}: Product ID is required`);
      }
      if (item.quantity <= 0) {
        throw new Error(`Item ${index + 1}: Quantity must be positive`);
      }
      if (item.unitPrice <= 0) {
        throw new Error(`Item ${index + 1}: Unit price must be positive`);
      }
    });
  }
}
```

### üîå Infrastructure Layer

Crear `src/order-management/infrastructure/repositories/PostgreSQLOrderRepository.ts`:

```typescript
import { Pool } from "pg";
import { OrderRepository } from "../../domain/repositories/OrderRepository";
import { Order } from "../../domain/entities/Order";
import { OrderItem } from "../../domain/entities/OrderItem";
import { OrderId } from "../../domain/value-objects/OrderId";
import { OrderStatusValue } from "../../domain/value-objects/OrderStatus";
import { Money } from "../../domain/value-objects/Money";

export class PostgreSQLOrderRepository implements OrderRepository {
  constructor(private db: Pool) {}

  async save(order: Order): Promise<void> {
    const client = await this.db.connect();

    try {
      await client.query("BEGIN");

      // Guardar orden principal
      await client.query(
        `
        INSERT INTO orders (id, user_id, status, total_amount, total_currency, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        ON CONFLICT (id) DO UPDATE SET
          status = EXCLUDED.status,
          total_amount = EXCLUDED.total_amount,
          total_currency = EXCLUDED.total_currency,
          updated_at = EXCLUDED.updated_at
      `,
        [
          order.getId().toString(),
          order.getUserId(),
          order.getStatus().toString(),
          order.getTotal().getAmount(),
          order.getTotal().getCurrency(),
          order.getCreatedAt(),
          order.getUpdatedAt(),
        ]
      );

      // Eliminar items existentes
      await client.query("DELETE FROM order_items WHERE order_id = $1", [
        order.getId().toString(),
      ]);

      // Insertar items nuevos
      for (const item of order.getItems()) {
        await client.query(
          `
          INSERT INTO order_items (order_id, product_id, quantity, unit_price, unit_currency)
          VALUES ($1, $2, $3, $4, $5)
        `,
          [
            order.getId().toString(),
            item.getProductId(),
            item.getQuantity(),
            item.getUnitPrice().getAmount(),
            item.getUnitPrice().getCurrency(),
          ]
        );
      }

      await client.query("COMMIT");
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  }

  async findById(id: OrderId): Promise<Order | null> {
    const result = await this.db.query(
      `
      SELECT 
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price,
            'unitCurrency', oi.unit_currency
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.id = $1
      GROUP BY o.id
    `,
      [id.toString()]
    );

    if (result.rows.length === 0) return null;

    return this.mapToOrder(result.rows[0]);
  }

  async findByUserId(userId: string): Promise<Order[]> {
    const result = await this.db.query(
      `
      SELECT 
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price,
            'unitCurrency', oi.unit_currency
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.user_id = $1
      GROUP BY o.id
      ORDER BY o.created_at DESC
    `,
      [userId]
    );

    return result.rows.map((row) => this.mapToOrder(row));
  }

  async findByStatus(status: OrderStatusValue): Promise<Order[]> {
    const result = await this.db.query(
      `
      SELECT 
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price,
            'unitCurrency', oi.unit_currency
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.status = $1
      GROUP BY o.id
      ORDER BY o.created_at DESC
    `,
      [status.toString()]
    );

    return result.rows.map((row) => this.mapToOrder(row));
  }

  async findAll(): Promise<Order[]> {
    const result = await this.db.query(`
      SELECT 
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price,
            'unitCurrency', oi.unit_currency
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      GROUP BY o.id
      ORDER BY o.created_at DESC
    `);

    return result.rows.map((row) => this.mapToOrder(row));
  }

  async delete(id: OrderId): Promise<void> {
    const client = await this.db.connect();

    try {
      await client.query("BEGIN");

      await client.query("DELETE FROM order_items WHERE order_id = $1", [
        id.toString(),
      ]);

      await client.query("DELETE FROM orders WHERE id = $1", [id.toString()]);

      await client.query("COMMIT");
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  }

  private mapToOrder(row: any): Order {
    const items = (row.items || []).map((itemData: any) =>
      OrderItem.create(
        itemData.productId,
        itemData.quantity,
        Money.fromAmount(itemData.unitPrice, itemData.unitCurrency)
      )
    );

    return Order.fromPersistence({
      id: OrderId.fromString(row.id),
      userId: row.user_id,
      items,
      status: row.status,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }
}
```

Crear `src/order-management/infrastructure/OrderManagementFactory.ts`:

```typescript
import { Pool } from "pg";
import { PostgreSQLOrderRepository } from "./repositories/PostgreSQLOrderRepository";
import { CreateOrderUseCase } from "../application/use-cases/CreateOrderUseCase";

export class OrderManagementFactory {
  private orderRepository: PostgreSQLOrderRepository;

  constructor(private database: Pool) {
    this.setupInfrastructure();
  }

  private setupInfrastructure(): void {
    this.orderRepository = new PostgreSQLOrderRepository(this.database);
  }

  // Use Cases
  createOrderUseCase(): CreateOrderUseCase {
    return new CreateOrderUseCase(this.orderRepository);
  }

  // Repository access
  getOrderRepository(): PostgreSQLOrderRepository {
    return this.orderRepository;
  }
}
```

---

## 6. Entrypoints Web

### üéÆ Controllers

Crear `entrypoints/web/controllers/UserController.ts`:

```typescript
import { Request, Response } from "express";
import { UserManagementFactory } from "../../../src/user-management/infrastructure/UserManagementFactory";
import { CreateUserRequest } from "../../../src/user-management/application/use-cases/CreateUserUseCase";
import { UserId } from "../../../src/user-management/domain/value-objects/UserId";

export class UserController {
  constructor(private userFactory: UserManagementFactory) {}

  async createUser(req: Request, res: Response): Promise<void> {
    try {
      const useCase = this.userFactory.createUserUseCase();

      const request = new CreateUserRequest(
        req.body.email,
        req.body.firstName,
        req.body.lastName
      );

      const response = await useCase.execute(request);

      res.status(201).json({
        success: true,
        data: response,
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message,
      });
    }
  }

  async getUser(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.userFactory.getUserRepository();
      const userId = UserId.fromString(req.params.id);
      const user = await repository.findById(userId);

      if (!user) {
        res.status(404).json({
          success: false,
          error: "User not found",
        });
        return;
      }

      res.json({
        success: true,
        data: {
          id: user.getId().toString(),
          email: user.getEmail().toString(),
          firstName: user.getFirstName(),
          lastName: user.getLastName(),
          fullName: user.getFullName(),
          createdAt: user.getCreatedAt(),
        },
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  async listUsers(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.userFactory.getUserRepository();
      const users = await repository.findAll();

      const usersData = users.map((user) => ({
        id: user.getId().toString(),
        email: user.getEmail().toString(),
        firstName: user.getFirstName(),
        lastName: user.getLastName(),
        fullName: user.getFullName(),
        createdAt: user.getCreatedAt(),
      }));

      res.json({
        success: true,
        data: usersData,
        count: usersData.length,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }
}
```

Crear `entrypoints/web/controllers/OrderController.ts`:

```typescript
import { Request, Response } from "express";
import { OrderManagementFactory } from "../../../src/order-management/infrastructure/OrderManagementFactory";
import { CreateOrderRequest } from "../../../src/order-management/application/use-cases/CreateOrderUseCase";
import { OrderId } from "../../../src/order-management/domain/value-objects/OrderId";

export class OrderController {
  constructor(private orderFactory: OrderManagementFactory) {}

  async createOrder(req: Request, res: Response): Promise<void> {
    try {
      const useCase = this.orderFactory.createOrderUseCase();

      const request = new CreateOrderRequest(req.body.userId, req.body.items);

      const response = await useCase.execute(request);

      res.status(201).json({
        success: true,
        data: response,
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message,
      });
    }
  }

  async getOrder(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.orderFactory.getOrderRepository();
      const orderId = OrderId.fromString(req.params.id);
      const order = await repository.findById(orderId);

      if (!order) {
        res.status(404).json({
          success: false,
          error: "Order not found",
        });
        return;
      }

      res.json({
        success: true,
        data: {
          id: order.getId().toString(),
          userId: order.getUserId(),
          status: order.getStatus().toString(),
          total: {
            amount: order.getTotal().getAmount(),
            currency: order.getTotal().getCurrency(),
            formatted: order.getTotal().toString(),
          },
          itemCount: order.getItemCount(),
          items: order.getItems().map((item) => ({
            productId: item.getProductId(),
            quantity: item.getQuantity(),
            unitPrice: {
              amount: item.getUnitPrice().getAmount(),
              currency: item.getUnitPrice().getCurrency(),
              formatted: item.getUnitPrice().toString(),
            },
            subtotal: {
              amount: item.getSubtotal().getAmount(),
              currency: item.getSubtotal().getCurrency(),
              formatted: item.getSubtotal().toString(),
            },
          })),
          createdAt: order.getCreatedAt(),
          updatedAt: order.getUpdatedAt(),
        },
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  async getUserOrders(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.orderFactory.getOrderRepository();
      const userId = req.params.userId;
      const orders = await repository.findByUserId(userId);

      const ordersData = orders.map((order) => ({
        id: order.getId().toString(),
        status: order.getStatus().toString(),
        total: order.getTotal().toString(),
        itemCount: order.getItemCount(),
        createdAt: order.getCreatedAt(),
      }));

      res.json({
        success: true,
        data: ordersData,
        count: ordersData.length,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  async listOrders(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.orderFactory.getOrderRepository();
      const orders = await repository.findAll();

      const ordersData = orders.map((order) => ({
        id: order.getId().toString(),
        userId: order.getUserId(),
        status: order.getStatus().toString(),
        total: order.getTotal().toString(),
        itemCount: order.getItemCount(),
        createdAt: order.getCreatedAt(),
      }));

      res.json({
        success: true,
        data: ordersData,
        count: ordersData.length,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }
}
```

### üõ§Ô∏è Routes

Crear `entrypoints/web/routes/userRoutes.ts`:

```typescript
import { Router } from "express";
import { UserController } from "../controllers/UserController";

export function createUserRoutes(userController: UserController): Router {
  const router = Router();

  // POST /api/users - Crear usuario
  router.post("/users", userController.createUser.bind(userController));

  // GET /api/users/:id - Obtener usuario por ID
  router.get("/users/:id", userController.getUser.bind(userController));

  // GET /api/users - Listar todos los usuarios
  router.get("/users", userController.listUsers.bind(userController));

  return router;
}
```

Crear `entrypoints/web/routes/orderRoutes.ts`:

```typescript
import { Router } from "express";
import { OrderController } from "../controllers/OrderController";

export function createOrderRoutes(orderController: OrderController): Router {
  const router = Router();

  // POST /api/orders - Crear orden
  router.post("/orders", orderController.createOrder.bind(orderController));

  // GET /api/orders/:id - Obtener orden por ID
  router.get("/orders/:id", orderController.getOrder.bind(orderController));

  // GET /api/orders - Listar todas las √≥rdenes
  router.get("/orders", orderController.listOrders.bind(orderController));

  // GET /api/users/:userId/orders - √ìrdenes de un usuario espec√≠fico
  router.get(
    "/users/:userId/orders",
    orderController.getUserOrders.bind(orderController)
  );

  return router;
}
```

### üì± App Configuration

Crear `entrypoints/web/app.ts`:

```typescript
import express from "express";
import cors from "cors";
import { Pool } from "pg";
import { createUserRoutes } from "./routes/userRoutes";
import { createOrderRoutes } from "./routes/orderRoutes";
import { UserController } from "./controllers/UserController";
import { OrderController } from "./controllers/OrderController";
import { UserManagementFactory } from "../../src/user-management/infrastructure/UserManagementFactory";
import { OrderManagementFactory } from "../../src/order-management/infrastructure/OrderManagementFactory";

export function createApp(database: Pool): express.Application {
  const app = express();

  // Middleware
  app.use(express.json({ limit: "10mb" }));
  app.use(express.urlencoded({ extended: true }));
  app.use(
    cors({
      origin: process.env.ALLOWED_ORIGINS?.split(",") || [
        "http://localhost:3000",
      ],
      credentials: true,
    })
  );

  // Request logging
  app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
    next();
  });

  // üè≠ Factories - Cada bounded context maneja su infrastructure
  const userFactory = new UserManagementFactory(database);
  const orderFactory = new OrderManagementFactory(database);

  // üéÆ Controllers
  const userController = new UserController(userFactory);
  const orderController = new OrderController(orderFactory);

  // üõ§Ô∏è Routes
  app.use("/api", createUserRoutes(userController));
  app.use("/api", createOrderRoutes(orderController));

  // Health check
  app.get("/health", (req, res) => {
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      boundedContexts: ["user-management", "order-management"],
      environment: process.env.NODE_ENV || "development",
    });
  });

  // API documentation
  app.get("/api", (req, res) => {
    res.json({
      name: "Screaming + Hexagonal Architecture API",
      version: "1.0.0",
      endpoints: {
        users: {
          "POST /api/users": "Create user",
          "GET /api/users": "List users",
          "GET /api/users/:id": "Get user by ID",
        },
        orders: {
          "POST /api/orders": "Create order",
          "GET /api/orders": "List orders",
          "GET /api/orders/:id": "Get order by ID",
          "GET /api/users/:userId/orders": "Get user orders",
        },
        system: {
          "GET /health": "Health check",
          "GET /api": "API documentation",
        },
      },
    });
  });

  // 404 handler
  app.use("*", (req, res) => {
    res.status(404).json({
      success: false,
      error: "Endpoint not found",
      suggestion: "Visit /api for available endpoints",
    });
  });

  // Error handling middleware
  app.use(
    (
      error: any,
      req: express.Request,
      res: express.Response,
      next: express.NextFunction
    ) => {
      console.error("Unhandled error:", error);

      res.status(500).json({
        success: false,
        error: "Internal server error",
        ...(process.env.NODE_ENV === "development" && {
          details: error.message,
        }),
      });
    }
  );

  return app;
}
```

### üöÄ Server

Crear `entrypoints/web/server.ts`:

```typescript
import { createApp } from "./app";
import { DatabaseConnection } from "../../shared/database/connection";
import { config } from "../../shared/config";

async function startServer() {
  try {
    console.log("üöÄ Starting server...");

    // üîå Conectar a la base de datos
    console.log("üìä Connecting to database...");
    const database = DatabaseConnection.getInstance();

    // Verificar conexi√≥n
    const isConnected = await DatabaseConnection.testConnection();
    if (!isConnected) {
      throw new Error("Failed to connect to database");
    }
    console.log("‚úÖ Database connected successfully");

    // üì± Crear aplicaci√≥n Express
    const app = createApp(database);

    // üöÄ Iniciar servidor
    const port = config.app.port;
    const server = app.listen(port, () => {
      console.log(`üöÄ Server running on port ${port}`);
      console.log(`üåç Environment: ${config.app.env}`);
      console.log(`üìö API docs: http://localhost:${port}/api`);
      console.log(`‚ù§Ô∏è  Health check: http://localhost:${port}/health`);
      console.log("");
      console.log("üéØ Available endpoints:");
      console.log("   POST /api/users - Create user");
      console.log("   GET  /api/users - List users");
      console.log("   POST /api/orders - Create order");
      console.log("   GET  /api/orders - List orders");
    });

    // Graceful shutdown
    process.on("SIGINT", () => gracefulShutdown(server));
    process.on("SIGTERM", () => gracefulShutdown(server));
  } catch (error) {
    console.error("‚ùå Failed to start server:", error);
    process.exit(1);
  }
}

async function gracefulShutdown(server: any) {
  console.log("\nüõë Shutting down server gracefully...");

  server.close(async () => {
    console.log("üì¥ HTTP server closed");

    try {
      await DatabaseConnection.close();
      console.log("üìä Database connection closed");
      console.log("‚úÖ Server shutdown complete");
      process.exit(0);
    } catch (error) {
      console.error("‚ùå Error during shutdown:", error);
      process.exit(1);
    }
  });

  // Force close after 10 seconds
  setTimeout(() => {
    console.log("‚è∞ Force closing server...");
    process.exit(1);
  }, 10000);
}

// Start the server
startServer();
```

---

## 7. Testing

### üß™ Configuraci√≥n de Testing

Crear `jest.config.js`:

```javascript
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
  roots: ["<rootDir>/tests", "<rootDir>/src"],
  testMatch: ["**/__tests__/**/*.ts", "**/?(*.)+(spec|test).ts"],
  transform: {
    "^.+\\.ts$": "ts-jest",
  },
  collectCoverageFrom: ["src/**/*.ts", "!src/**/*.d.ts", "!src/**/*Factory.ts"],
  coverageDirectory: "coverage",
  coverageReporters: ["text", "lcov", "html"],
};
```

### üß™ Tests Unitarios

Crear `tests/unit/user-management/domain/entities/User.test.ts`:

```typescript
import { User } from "../../../../../src/user-management/domain/entities/User";
import { Email } from "../../../../../src/user-management/domain/value-objects/Email";

describe("User Entity", () => {
  describe("creation", () => {
    it("should create a valid user", () => {
      // Arrange
      const email = Email.fromString("test@example.com");
      const firstName = "John";
      const lastName = "Doe";

      // Act
      const user = User.create(email, firstName, lastName);

      // Assert
      expect(user.getEmail().toString()).toBe("test@example.com");
      expect(user.getFirstName()).toBe("John");
      expect(user.getLastName()).toBe("Doe");
      expect(user.getFullName()).toBe("John Doe");
      expect(user.getId()).toBeDefined();
      expect(user.getCreatedAt()).toBeInstanceOf(Date);
    });

    it("should generate unique IDs for different users", () => {
      // Arrange
      const email1 = Email.fromString("user1@example.com");
      const email2 = Email.fromString("user2@example.com");

      // Act
      const user1 = User.create(email1, "User", "One");
      const user2 = User.create(email2, "User", "Two");

      // Assert
      expect(user1.getId().toString()).not.toBe(user2.getId().toString());
    });
  });

  describe("business rules", () => {
    it("should allow notifications for normal domains", () => {
      // Arrange
      const email = Email.fromString("user@example.com");
      const user = User.create(email, "John", "Doe");

      // Act & Assert
      expect(user.canReceiveNotifications()).toBe(true);
    });

    it("should not allow notifications for restricted domains", () => {
      // Arrange
      const email = Email.fromString("user@spam.com");
      const user = User.create(email, "John", "Doe");

      // Act & Assert
      expect(user.canReceiveNotifications()).toBe(false);
    });
  });

  describe("profile updates", () => {
    it("should update profile information", () => {
      // Arrange
      const email = Email.fromString("test@example.com");
      const user = User.create(email, "John", "Doe");
      const originalUpdatedAt = user.getUpdatedAt();

      // Wait a bit to ensure different timestamp
      setTimeout(() => {
        // Act
        user.updateProfile("Jane", "Smith");

        // Assert
        expect(user.getFirstName()).toBe("Jane");
        expect(user.getLastName()).toBe("Smith");
        expect(user.getFullName()).toBe("Jane Smith");
        expect(user.getUpdatedAt().getTime()).toBeGreaterThan(
          originalUpdatedAt.getTime()
        );
      }, 1);
    });
  });
});
```

Crear `tests/unit/order-management/domain/entities/Order.test.ts`:

````typescript
import { Order } from '../../../../../src/order-management/domain/entities/Order';
import { OrderItem } from '../../../../../src/order-management/domain/entities/OrderItem';
import { Money } from '../../../../../src/order-management/domain/value-objects/Money';
import { OrderStatus } from '../../../../../src/order-management/domain/value-objects/OrderStatus';

describe('Order Entity', () => {
  const createSampleOrderItem = (productId: string = 'prod1', quantity: number = 2, price: number = 10.00) => {
    return OrderItem.create(productId, quantity, Money.fromAmount(price, 'USD'));
  };

  describe('creation', () => {
    it('should create a valid order', () => {
      // Arrange
      const userId = 'user123';
      const items = [createSampleOrderItem()];

      // Act
      const order = Order.create(userId, items);

      // Assert
      expect(order.getUserId()).toBe('user123');
      expect(order.getItems()).toHaveLength(1);
      expect(order.getStatus().isPending()).toBe(true);
      expect(order.getTotal().getAmount()).toBe(20.00); // 2 * 10.00
      expect(order.getId()).toBeDefined();
    });

    it('should throw error when creating order without items', () => {
      // Arrange
      const userId = 'user123';
      const items: OrderItem[] = [];

      // Act & Assert
      expect(() => Order.create(userId, items)).toThrow('Order must have at least one item');
    });

    it('should throw error when creating order without userId', () => {
      // Arrange
      const userId = '';
      const items = [createSampleOrderItem()];

      // Act & Assert
      expect(() => Order.create(userId, items)).toThrow('User ID is required');
    });
  });

  describe('business rules', () => {
    it('should allow modifications only when pending', () => {
      // Arrange
      const order = Order.create('user123', [createSampleOrderItem()]);

      // Act &# üèóÔ∏è Tutorial: Screaming + Hexagonal Architecture
## Con Infrastructure por Bounded Context

### üìö √çndice
1. [Preparaci√≥n del Proyecto](#1-preparaci√≥n-del-proyecto)
2. [Estructura Base](#2-estructura-base)
3. [Shared Infrastructure](#3-shared-infrastructure)
4. [Primer Bounded Context: User Management](#4-primer-bounded-context-user-management)
5. [Segundo Bounded Context: Order Management](#5-segundo-bounded-context-order-management)
6. [Entrypoints Web](#6-entrypoints-web)
7. [Testing](#7-testing)
8. [Extensiones y Mejoras](#8-extensiones-y-mejoras)

---

## 1. Preparaci√≥n del Proyecto

### üöÄ Inicializar Proyecto

```bash
mkdir screaming-hex-architecture
cd screaming-hex-architecture
npm init -y
````

### üì¶ Instalar Dependencias

```bash
# Dependencias principales
npm install express cors pg dotenv

# DevDependencies
npm install -D typescript @types/node @types/express @types/pg ts-node nodemon

# Testing (opcional para el final)
npm install -D jest @types/jest ts-jest
```

### ‚öôÔ∏è Configuraci√≥n TypeScript

Crear `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*", "entrypoints/**/*", "shared/**/*", "config/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### üìã Package.json Scripts

Actualizar `package.json`:

```json
{
  "scripts": {
    "dev": "nodemon --exec ts-node entrypoints/web/server.ts",
    "build": "tsc",
    "start": "node dist/entrypoints/web/server.js",
    "test": "jest",
    "test:watch": "jest --watch"
  }
}
```

---

## 2. Estructura Base

### üìÅ Crear Directorios

```bash
mkdir -p src/{user-management,order-management}
mkdir -p src/user-management/{domain,application,infrastructure}
mkdir -p src/order-management/{domain,application,infrastructure}
mkdir -p entrypoints/{web,cli,messaging}
mkdir -p shared/{database,config,utils}
mkdir -p config
mkdir -p tests/{unit,integration,e2e}
```

### üéØ Verificar Estructura

```
proyecto/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ user-management/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îî‚îÄ‚îÄ order-management/
‚îÇ       ‚îú‚îÄ‚îÄ domain/
‚îÇ       ‚îú‚îÄ‚îÄ application/
‚îÇ       ‚îî‚îÄ‚îÄ infrastructure/
‚îú‚îÄ‚îÄ entrypoints/
‚îÇ   ‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îî‚îÄ‚îÄ messaging/
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ config/
‚îî‚îÄ‚îÄ tests/
```

---

## 3. Shared Infrastructure

### üîß Variables de Entorno

Crear `.env`:

```env
# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=screaming_arch_db
DB_USER=postgres
DB_PASSWORD=your_password

# Application
NODE_ENV=development
PORT=3000

# External Services
STRIPE_SECRET_KEY=sk_test_...
SENDGRID_API_KEY=SG...
```

### üîå Database Connection

Crear `shared/database/connection.ts`:

```typescript
import { Pool } from "pg";

export class DatabaseConnection {
  private static instance: Pool;

  static getInstance(): Pool {
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new Pool({
        host: process.env.DB_HOST || "localhost",
        port: parseInt(process.env.DB_PORT || "5432"),
        database: process.env.DB_NAME || "screaming_arch_db",
        user: process.env.DB_USER || "postgres",
        password: process.env.DB_PASSWORD || "password",
        max: 20, // pool size
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 2000,
      });

      // Manejo de errores del pool
      DatabaseConnection.instance.on("error", (err) => {
        console.error("Unexpected error on idle client", err);
      });
    }
    return DatabaseConnection.instance;
  }

  static async close(): Promise<void> {
    if (DatabaseConnection.instance) {
      await DatabaseConnection.instance.end();
    }
  }

  // M√©todo para testing
  static async testConnection(): Promise<boolean> {
    try {
      const pool = DatabaseConnection.getInstance();
      await pool.query("SELECT NOW()");
      return true;
    } catch (error) {
      console.error("Database connection failed:", error);
      return false;
    }
  }
}
```

### ‚öôÔ∏è Configuraci√≥n Global

Crear `shared/config/index.ts`:

```typescript
import dotenv from "dotenv";

dotenv.config();

export const config = {
  database: {
    host: process.env.DB_HOST || "localhost",
    port: parseInt(process.env.DB_PORT || "5432"),
    name: process.env.DB_NAME || "screaming_arch_db",
    user: process.env.DB_USER || "postgres",
    password: process.env.DB_PASSWORD || "password",
  },
  app: {
    port: parseInt(process.env.PORT || "3000"),
    env: process.env.NODE_ENV || "development",
  },
  services: {
    stripe: {
      secretKey: process.env.STRIPE_SECRET_KEY || "",
    },
    sendgrid: {
      apiKey: process.env.SENDGRID_API_KEY || "",
    },
  },
};
```

---

## 4. Primer Bounded Context: User Management

### üéØ Domain Layer

#### Value Objects

Crear `src/user-management/domain/value-objects/UserId.ts`:

```typescript
export class UserId {
  private constructor(private readonly value: string) {
    this.validate(value);
  }

  private validate(value: string): void {
    if (!value || value.trim().length === 0) {
      throw new Error("UserId cannot be empty");
    }
    if (!/^[a-zA-Z0-9-_]+$/.test(value)) {
      throw new Error(
        "UserId must contain only alphanumeric characters, hyphens, and underscores"
      );
    }
  }

  static generate(): UserId {
    const id =
      "user_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
    return new UserId(id);
  }

  static fromString(value: string): UserId {
    return new UserId(value);
  }

  toString(): string {
    return this.value;
  }

  equals(other: UserId): boolean {
    return this.value === other.value;
  }
}
```

Crear `src/user-management/domain/value-objects/Email.ts`:

```typescript
export class Email {
  private constructor(private readonly value: string) {
    this.validate(value);
  }

  private validate(value: string): void {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      throw new Error("Invalid email format");
    }
  }

  static fromString(value: string): Email {
    return new Email(value.toLowerCase().trim());
  }

  toString(): string {
    return this.value;
  }

  getDomain(): string {
    return this.value.split("@")[1];
  }

  equals(other: Email): boolean {
    return this.value === other.value;
  }
}
```

#### Entities

Crear `src/user-management/domain/entities/User.ts`:

```typescript
import { UserId } from "../value-objects/UserId";
import { Email } from "../value-objects/Email";

export class User {
  private constructor(
    private id: UserId,
    private email: Email,
    private firstName: string,
    private lastName: string,
    private createdAt: Date,
    private updatedAt: Date = new Date()
  ) {}

  // Factory method para crear nuevo usuario
  static create(email: Email, firstName: string, lastName: string): User {
    return new User(UserId.generate(), email, firstName, lastName, new Date());
  }

  // Factory method para reconstruir desde persistencia
  static fromPersistence(data: {
    id: UserId;
    email: Email;
    firstName: string;
    lastName: string;
    createdAt: Date;
    updatedAt?: Date;
  }): User {
    return new User(
      data.id,
      data.email,
      data.firstName,
      data.lastName,
      data.createdAt,
      data.updatedAt || new Date()
    );
  }

  // Getters
  getId(): UserId {
    return this.id;
  }
  getEmail(): Email {
    return this.email;
  }
  getFirstName(): string {
    return this.firstName;
  }
  getLastName(): string {
    return this.lastName;
  }
  getCreatedAt(): Date {
    return this.createdAt;
  }
  getUpdatedAt(): Date {
    return this.updatedAt;
  }

  // M√©todos de negocio
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }

  updateProfile(firstName: string, lastName: string): void {
    this.firstName = firstName;
    this.lastName = lastName;
    this.updatedAt = new Date();
  }

  changeEmail(newEmail: Email): void {
    this.email = newEmail;
    this.updatedAt = new Date();
  }

  // Reglas de negocio
  canReceiveNotifications(): boolean {
    // Ejemplo: usuarios con emails de dominios espec√≠ficos no reciben notificaciones
    const restrictedDomains = ["spam.com", "fake.com"];
    return !restrictedDomains.includes(this.email.getDomain());
  }
}
```

#### Repository Interface

Crear `src/user-management/domain/repositories/UserRepository.ts`:

```typescript
import { User } from "../entities/User";
import { UserId } from "../value-objects/UserId";
import { Email } from "../value-objects/Email";

export interface UserRepository {
  save(user: User): Promise<void>;
  findById(id: UserId): Promise<User | null>;
  findByEmail(email: Email): Promise<User | null>;
  findAll(): Promise<User[]>;
  delete(id: UserId): Promise<void>;
  existsByEmail(email: Email): Promise<boolean>;
}
```

### ‚ö° Application Layer

#### Use Cases

Crear `src/user-management/application/use-cases/CreateUserUseCase.ts`:

```typescript
import { User } from "../../domain/entities/User";
import { Email } from "../../domain/value-objects/Email";
import { UserRepository } from "../../domain/repositories/UserRepository";

export class CreateUserRequest {
  constructor(
    public readonly email: string,
    public readonly firstName: string,
    public readonly lastName: string
  ) {}
}

export class CreateUserResponse {
  constructor(
    public readonly userId: string,
    public readonly email: string,
    public readonly fullName: string
  ) {}
}

export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(request: CreateUserRequest): Promise<CreateUserResponse> {
    // Validar entrada
    this.validateRequest(request);

    const email = Email.fromString(request.email);

    // Verificar que el email no exista
    const existingUser = await this.userRepository.findByEmail(email);
    if (existingUser) {
      throw new Error(`User with email ${request.email} already exists`);
    }

    // Crear usuario
    const user = User.create(email, request.firstName, request.lastName);

    // Guardar
    await this.userRepository.save(user);

    return new CreateUserResponse(
      user.getId().toString(),
      user.getEmail().toString(),
      user.getFullName()
    );
  }

  private validateRequest(request: CreateUserRequest): void {
    if (!request.firstName?.trim()) {
      throw new Error("First name is required");
    }
    if (!request.lastName?.trim()) {
      throw new Error("Last name is required");
    }
    if (!request.email?.trim()) {
      throw new Error("Email is required");
    }
  }
}
```

### üîå Infrastructure Layer

#### Repository Implementation

Crear `src/user-management/infrastructure/repositories/PostgreSQLUserRepository.ts`:

```typescript
import { Pool } from "pg";
import { UserRepository } from "../../domain/repositories/UserRepository";
import { User } from "../../domain/entities/User";
import { UserId } from "../../domain/value-objects/UserId";
import { Email } from "../../domain/value-objects/Email";

export class PostgreSQLUserRepository implements UserRepository {
  constructor(private db: Pool) {}

  async save(user: User): Promise<void> {
    await this.db.query(
      `
      INSERT INTO users (id, email, first_name, last_name, created_at, updated_at)
      VALUES ($1, $2, $3, $4, $5, $6)
      ON CONFLICT (id) DO UPDATE SET
        email = EXCLUDED.email,
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        updated_at = EXCLUDED.updated_at
    `,
      [
        user.getId().toString(),
        user.getEmail().toString(),
        user.getFirstName(),
        user.getLastName(),
        user.getCreatedAt(),
        user.getUpdatedAt(),
      ]
    );
  }

  async findById(id: UserId): Promise<User | null> {
    const result = await this.db.query(
      `
      SELECT * FROM users WHERE id = $1
    `,
      [id.toString()]
    );

    if (result.rows.length === 0) return null;

    return this.mapToUser(result.rows[0]);
  }

  async findByEmail(email: Email): Promise<User | null> {
    const result = await this.db.query(
      `
      SELECT * FROM users WHERE email = $1
    `,
      [email.toString()]
    );

    if (result.rows.length === 0) return null;

    return this.mapToUser(result.rows[0]);
  }

  async findAll(): Promise<User[]> {
    const result = await this.db.query(`
      SELECT * FROM users ORDER BY created_at DESC
    `);

    return result.rows.map((row) => this.mapToUser(row));
  }

  async delete(id: UserId): Promise<void> {
    await this.db.query(
      `
      DELETE FROM users WHERE id = $1
    `,
      [id.toString()]
    );
  }

  async existsByEmail(email: Email): Promise<boolean> {
    const result = await this.db.query(
      `
      SELECT 1 FROM users WHERE email = $1 LIMIT 1
    `,
      [email.toString()]
    );

    return result.rows.length > 0;
  }

  private mapToUser(row: any): User {
    return User.fromPersistence({
      id: UserId.fromString(row.id),
      email: Email.fromString(row.email),
      firstName: row.first_name,
      lastName: row.last_name,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }
}
```

#### Factory

Crear `src/user-management/infrastructure/UserManagementFactory.ts`:

```typescript
import { Pool } from "pg";
import { PostgreSQLUserRepository } from "./repositories/PostgreSQLUserRepository";
import { CreateUserUseCase } from "../application/use-cases/CreateUserUseCase";

export class UserManagementFactory {
  private userRepository: PostgreSQLUserRepository;

  constructor(private database: Pool) {
    this.setupInfrastructure();
  }

  private setupInfrastructure(): void {
    this.userRepository = new PostgreSQLUserRepository(this.database);
  }

  // Use Cases
  createUserUseCase(): CreateUserUseCase {
    return new CreateUserUseCase(this.userRepository);
  }

  // Repository access (para otros bounded contexts si necesario)
  getUserRepository(): PostgreSQLUserRepository {
    return this.userRepository;
  }
}
```

---

## 5. Segundo Bounded Context: Order Management

### üéØ Domain Layer

#### Value Objects

Crear `src/order-management/domain/value-objects/OrderId.ts`:

```typescript
export class OrderId {
  private constructor(private readonly value: string) {
    this.validate(value);
  }

  private validate(value: string): void {
    if (!value || value.trim().length === 0) {
      throw new Error("OrderId cannot be empty");
    }
  }

  static generate(): OrderId {
    const timestamp =
      new Date().getFullYear().toString().substr(-2) +
      String(Date.now()).substr(-8);
    const random = Math.random().toString(36).substr(2, 4).toUpperCase();
    const id = `ORD-${timestamp}-${random}`;
    return new OrderId(id);
  }

  static fromString(value: string): OrderId {
    return new OrderId(value);
  }

  toString(): string {
    return this.value;
  }

  equals(other: OrderId): boolean {
    return this.value === other.value;
  }
}
```

Crear `src/order-management/domain/value-objects/Money.ts`:

```typescript
export class Money {
  private constructor(
    private readonly amount: number,
    private readonly currency: string
  ) {
    this.validate(amount, currency);
  }

  private validate(amount: number, currency: string): void {
    if (amount < 0) {
      throw new Error("Amount cannot be negative");
    }
    if (!currency || currency.length !== 3) {
      throw new Error("Currency must be a 3-letter code");
    }
  }

  static fromAmount(amount: number, currency: string = "USD"): Money {
    return new Money(amount, currency.toUpperCase());
  }

  static zero(currency: string = "USD"): Money {
    return new Money(0, currency.toUpperCase());
  }

  getAmount(): number {
    return this.amount;
  }
  getCurrency(): string {
    return this.currency;
  }

  add(other: Money): Money {
    this.ensureSameCurrency(other);
    return new Money(this.amount + other.amount, this.currency);
  }

  subtract(other: Money): Money {
    this.ensureSameCurrency(other);
    return new Money(this.amount - other.amount, this.currency);
  }

  multiply(factor: number): Money {
    return new Money(this.amount * factor, this.currency);
  }

  equals(other: Money): boolean {
    return this.amount === other.amount && this.currency === other.currency;
  }

  isGreaterThan(other: Money): boolean {
    this.ensureSameCurrency(other);
    return this.amount > other.amount;
  }

  toString(): string {
    return `${this.amount.toFixed(2)} ${this.currency}`;
  }

  private ensureSameCurrency(other: Money): void {
    if (this.currency !== other.currency) {
      throw new Error(
        `Cannot operate with different currencies: ${this.currency} vs ${other.currency}`
      );
    }
  }
}
```

Crear `src/order-management/domain/value-objects/OrderStatus.ts`:

```typescript
export enum OrderStatus {
  PENDING = "PENDING",
  CONFIRMED = "CONFIRMED",
  PAID = "PAID",
  SHIPPED = "SHIPPED",
  DELIVERED = "DELIVERED",
  CANCELLED = "CANCELLED",
}

export class OrderStatusValue {
  private constructor(private readonly status: OrderStatus) {}

  static fromString(status: string): OrderStatusValue {
    const upperStatus = status.toUpperCase();
    if (!Object.values(OrderStatus).includes(upperStatus as OrderStatus)) {
      throw new Error(`Invalid order status: ${status}`);
    }
    return new OrderStatusValue(upperStatus as OrderStatus);
  }

  static pending(): OrderStatusValue {
    return new OrderStatusValue(OrderStatus.PENDING);
  }

  static confirmed(): OrderStatusValue {
    return new OrderStatusValue(OrderStatus.CONFIRMED);
  }

  getValue(): OrderStatus {
    return this.status;
  }

  toString(): string {
    return this.status;
  }

  isPending(): boolean {
    return this.status === OrderStatus.PENDING;
  }
  isConfirmed(): boolean {
    return this.status === OrderStatus.CONFIRMED;
  }
  isPaid(): boolean {
    return this.status === OrderStatus.PAID;
  }
  isShipped(): boolean {
    return this.status === OrderStatus.SHIPPED;
  }
  isDelivered(): boolean {
    return this.status === OrderStatus.DELIVERED;
  }
  isCancelled(): boolean {
    return this.status === OrderStatus.CANCELLED;
  }

  canTransitionTo(newStatus: OrderStatusValue): boolean {
    const transitions: Record<OrderStatus, OrderStatus[]> = {
      [OrderStatus.PENDING]: [OrderStatus.CONFIRMED, OrderStatus.CANCELLED],
      [OrderStatus.CONFIRMED]: [OrderStatus.PAID, OrderStatus.CANCELLED],
      [OrderStatus.PAID]: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
      [OrderStatus.SHIPPED]: [OrderStatus.DELIVERED],
      [OrderStatus.DELIVERED]: [],
      [OrderStatus.CANCELLED]: [],
    };

    return transitions[this.status].includes(newStatus.getValue());
  }
}
```

#### Entities

Crear `src/order-management/domain/entities/OrderItem.ts`:

```typescript
import { Money } from "../value-objects/Money";

export class OrderItem {
  private constructor(
    private productId: string,
    private quantity: number,
    private unitPrice: Money
  ) {
    this.validate();
  }

  static create(
    productId: string,
    quantity: number,
    unitPrice: Money
  ): OrderItem {
    return new OrderItem(productId, quantity, unitPrice);
  }

  private validate(): void {
    if (!this.productId?.trim()) {
      throw new Error("Product ID is required");
    }
    if (this.quantity <= 0) {
      throw new Error("Quantity must be positive");
    }
  }

  getProductId(): string {
    return this.productId;
  }
  getQuantity(): number {
    return this.quantity;
  }
  getUnitPrice(): Money {
    return this.unitPrice;
  }

  getSubtotal(): Money {
    return this.unitPrice.multiply(this.quantity);
  }

  changeQuantity(newQuantity: number): void {
    if (newQuantity <= 0) {
      throw new Error("Quantity must be positive");
    }
    this.quantity = newQuantity;
  }

  updatePrice(newPrice: Money): void {
    this.unitPrice = newPrice;
  }
}
```

Crear `src/order-management/domain/entities/Order.ts`:

```typescript
import { OrderId } from "../value-objects/OrderId";
import { Money } from "../value-objects/Money";
import { OrderStatusValue, OrderStatus } from "../value-objects/OrderStatus";
import { OrderItem } from "./OrderItem";

export class Order {
  private constructor(
    private id: OrderId,
    private userId: string,
    private items: OrderItem[],
    private status: OrderStatusValue,
    private createdAt: Date,
    private updatedAt: Date = new Date()
  ) {}

  static create(userId: string, items: OrderItem[]): Order {
    if (!userId?.trim()) {
      throw new Error("User ID is required");
    }
    if (!items || items.length === 0) {
      throw new Error("Order must have at least one item");
    }

    return new Order(
      OrderId.generate(),
      userId,
      [...items], // defensive copy
      OrderStatusValue.pending(),
      new Date()
    );
  }

  static fromPersistence(data: {
    id: OrderId;
    userId: string;
    items: OrderItem[];
    status: string;
    createdAt: Date;
    updatedAt?: Date;
  }): Order {
    return new Order(
      data.id,
      data.userId,
      data.items,
      OrderStatusValue.fromString(data.status),
      data.createdAt,
      data.updatedAt || new Date()
    );
  }

  // Getters
  getId(): OrderId {
    return this.id;
  }
  getUserId(): string {
    return this.userId;
  }
  getItems(): OrderItem[] {
    return [...this.items];
  } // defensive copy
  getStatus(): OrderStatusValue {
    return this.status;
  }
  getCreatedAt(): Date {
    return this.createdAt;
  }
  getUpdatedAt(): Date {
    return this.updatedAt;
  }

  // Calculated properties
  getTotal(): Money {
    if (this.items.length === 0) {
      return Money.zero();
    }

    return this.items
      .map((item) => item.getSubtotal())
      .reduce((total, subtotal) => total.add(subtotal));
  }

  getItemCount(): number {
    return this.items.reduce((total, item) => total + item.getQuantity(), 0);
  }

  // Business methods
  addItem(item: OrderItem): void {
    if (!this.canBeModified()) {
      throw new Error("Cannot modify order in current status");
    }

    // Check if product already exists
    const existingItemIndex = this.items.findIndex(
      (existing) => existing.getProductId() === item.getProductId()
    );

    if (existingItemIndex >= 0) {
      // Update quantity
      const existingItem = this.items[existingItemIndex];
      existingItem.changeQuantity(
        existingItem.getQuantity() + item.getQuantity()
      );
    } else {
      // Add new item
      this.items.push(item);
    }

    this.updatedAt = new Date();
  }

  removeItem(productId: string): void {
    if (!this.canBeModified()) {
      throw new Error("Cannot modify order in current status");
    }

    this.items = this.items.filter((item) => item.getProductId() !== productId);
    this.updatedAt = new Date();
  }

  confirm(): void {
    this.changeStatus(OrderStatusValue.confirmed());
  }

  markAsPaid(): void {
    this.changeStatus(OrderStatusValue.fromString(OrderStatus.PAID));
  }

  ship(): void {
    this.changeStatus(OrderStatusValue.fromString(OrderStatus.SHIPPED));
  }

  deliver(): void {
    this.changeStatus(OrderStatusValue.fromString(OrderStatus.DELIVERED));
  }

  cancel(): void {
    if (this.status.isDelivered()) {
      throw new Error("Cannot cancel delivered order");
    }
    this.changeStatus(OrderStatusValue.fromString(OrderStatus.CANCELLED));
  }

  // Business rules
  canBeModified(): boolean {
    return this.status.isPending();
  }

  canBePaid(): boolean {
    return this.status.isConfirmed();
  }

  canBeCancelled(): boolean {
    return !this.status.isDelivered() && !this.status.isCancelled();
  }

  private changeStatus(newStatus: OrderStatusValue): void {
    if (!this.status.canTransitionTo(newStatus)) {
      throw new Error(`Cannot transition from ${this.status} to ${newStatus}`);
    }

    this.status = newStatus;
    this.updatedAt = new Date();
  }
}
```

#### Repository Interface

Crear `src/order-management/domain/repositories/OrderRepository.ts`:

```typescript
import { Order } from "../entities/Order";
import { OrderId } from "../value-objects/OrderId";
import { OrderStatusValue } from "../value-objects/OrderStatus";

export interface OrderRepository {
  save(order: Order): Promise<void>;
  findById(id: OrderId): Promise<Order | null>;
  findByUserId(userId: string): Promise<Order[]>;
  findByStatus(status: OrderStatusValue): Promise<Order[]>;
  findAll(): Promise<Order[]>;
  delete(id: OrderId): Promise<void>;
}
```

### ‚ö° Application Layer

Crear `src/order-management/application/use-cases/CreateOrderUseCase.ts`:

```typescript
import { Order } from "../../domain/entities/Order";
import { OrderItem } from "../../domain/entities/OrderItem";
import { Money } from "../../domain/value-objects/Money";
import { OrderRepository } from "../../domain/repositories/OrderRepository";

export class CreateOrderRequest {
  constructor(
    public readonly userId: string,
    public readonly items: Array<{
      productId: string;
      quantity: number;
      unitPrice: number;
      currency?: string;
    }>
  ) {}
}

export class CreateOrderResponse {
  constructor(
    public readonly orderId: string,
    public readonly userId: string,
    public readonly total: string,
    public readonly status: string
  ) {}
}

export class CreateOrderUseCase {
  constructor(private orderRepository: OrderRepository) {}

  async execute(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    // Validar entrada
    this.validateRequest(request);

    // Crear items del dominio
    const orderItems = request.items.map((item) =>
      OrderItem.create(
        item.productId,
        item.quantity,
        Money.fromAmount(item.unitPrice, item.currency || "USD")
      )
    );

    // Crear orden
    const order = Order.create(request.userId, orderItems);

    // Guardar
    await this.orderRepository.save(order);

    return new CreateOrderResponse(
      order.getId().toString(),
      order.getUserId(),
      order.getTotal().toString(),
      order.getStatus().toString()
    );
  }

  private validateRequest(request: CreateOrderRequest): void {
    if (!request.userId?.trim()) {
      throw new Error("User ID is required");
    }

    if (!request.items || request.items.length === 0) {
      throw new Error("Order must have at least one item");
    }

    request.items.forEach((item, index) => {
      if (!item.productId?.trim()) {
        throw new Error(`Item ${index + 1}: Product ID is required`);
      }
      if (item.quantity <= 0) {
        throw new Error(`Item ${index + 1}: Quantity must be positive`);
      }
      if (item.unitPrice <= 0) {
        throw new Error(`Item ${index + 1}: Unit price must be positive`);
      }
    });
  }
}
```

### üîå Infrastructure Layer

Crear `src/order-management/infrastructure/repositories/PostgreSQLOrderRepository.ts`:

```typescript
import { Pool } from "pg";
import { OrderRepository } from "../../domain/repositories/OrderRepository";
import { Order } from "../../domain/entities/Order";
import { OrderItem } from "../../domain/entities/OrderItem";
import { OrderId } from "../../domain/value-objects/OrderId";
import { OrderStatusValue } from "../../domain/value-objects/OrderStatus";
import { Money } from "../../domain/value-objects/Money";

export class PostgreSQLOrderRepository implements OrderRepository {
  constructor(private db: Pool) {}

  async save(order: Order): Promise<void> {
    const client = await this.db.connect();

    try {
      await client.query("BEGIN");

      // Guardar orden principal
      await client.query(
        `
        INSERT INTO orders (id, user_id, status, total_amount, total_currency, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        ON CONFLICT (id) DO UPDATE SET
          status = EXCLUDED.status,
          total_amount = EXCLUDED.total_amount,
          total_currency = EXCLUDED.total_currency,
          updated_at = EXCLUDED.updated_at
      `,
        [
          order.getId().toString(),
          order.getUserId(),
          order.getStatus().toString(),
          order.getTotal().getAmount(),
          order.getTotal().getCurrency(),
          order.getCreatedAt(),
          order.getUpdatedAt(),
        ]
      );

      // Eliminar items existentes
      await client.query("DELETE FROM order_items WHERE order_id = $1", [
        order.getId().toString(),
      ]);

      // Insertar items nuevos
      for (const item of order.getItems()) {
        await client.query(
          `
          INSERT INTO order_items (order_id, product_id, quantity, unit_price, unit_currency)
          VALUES ($1, $2, $3, $4, $5)
        `,
          [
            order.getId().toString(),
            item.getProductId(),
            item.getQuantity(),
            item.getUnitPrice().getAmount(),
            item.getUnitPrice().getCurrency(),
          ]
        );
      }

      await client.query("COMMIT");
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  }

  async findById(id: OrderId): Promise<Order | null> {
    const result = await this.db.query(
      `
      SELECT 
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price,
            'unitCurrency', oi.unit_currency
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.id = $1
      GROUP BY o.id
    `,
      [id.toString()]
    );

    if (result.rows.length === 0) return null;

    return this.mapToOrder(result.rows[0]);
  }

  async findByUserId(userId: string): Promise<Order[]> {
    const result = await this.db.query(
      `
      SELECT 
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price,
            'unitCurrency', oi.unit_currency
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.user_id = $1
      GROUP BY o.id
      ORDER BY o.created_at DESC
    `,
      [userId]
    );

    return result.rows.map((row) => this.mapToOrder(row));
  }

  async findByStatus(status: OrderStatusValue): Promise<Order[]> {
    const result = await this.db.query(
      `
      SELECT 
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price,
            'unitCurrency', oi.unit_currency
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.status = $1
      GROUP BY o.id
      ORDER BY o.created_at DESC
    `,
      [status.toString()]
    );

    return result.rows.map((row) => this.mapToOrder(row));
  }

  async findAll(): Promise<Order[]> {
    const result = await this.db.query(`
      SELECT 
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price,
            'unitCurrency', oi.unit_currency
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      GROUP BY o.id
      ORDER BY o.created_at DESC
    `);

    return result.rows.map((row) => this.mapToOrder(row));
  }

  async delete(id: OrderId): Promise<void> {
    const client = await this.db.connect();

    try {
      await client.query("BEGIN");

      await client.query("DELETE FROM order_items WHERE order_id = $1", [
        id.toString(),
      ]);

      await client.query("DELETE FROM orders WHERE id = $1", [id.toString()]);

      await client.query("COMMIT");
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  }

  private mapToOrder(row: any): Order {
    const items = (row.items || []).map((itemData: any) =>
      OrderItem.create(
        itemData.productId,
        itemData.quantity,
        Money.fromAmount(itemData.unitPrice, itemData.unitCurrency)
      )
    );

    return Order.fromPersistence({
      id: OrderId.fromString(row.id),
      userId: row.user_id,
      items,
      status: row.status,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }
}
```

Crear `src/order-management/infrastructure/OrderManagementFactory.ts`:

```typescript
import { Pool } from "pg";
import { PostgreSQLOrderRepository } from "./repositories/PostgreSQLOrderRepository";
import { CreateOrderUseCase } from "../application/use-cases/CreateOrderUseCase";

export class OrderManagementFactory {
  private orderRepository: PostgreSQLOrderRepository;

  constructor(private database: Pool) {
    this.setupInfrastructure();
  }

  private setupInfrastructure(): void {
    this.orderRepository = new PostgreSQLOrderRepository(this.database);
  }

  // Use Cases
  createOrderUseCase(): CreateOrderUseCase {
    return new CreateOrderUseCase(this.orderRepository);
  }

  // Repository access
  getOrderRepository(): PostgreSQLOrderRepository {
    return this.orderRepository;
  }
}
```

---

## 6. Entrypoints Web

### üéÆ Controllers

Crear `entrypoints/web/controllers/UserController.ts`:

```typescript
import { Request, Response } from "express";
import { UserManagementFactory } from "../../../src/user-management/infrastructure/UserManagementFactory";
import { CreateUserRequest } from "../../../src/user-management/application/use-cases/CreateUserUseCase";
import { UserId } from "../../../src/user-management/domain/value-objects/UserId";

export class UserController {
  constructor(private userFactory: UserManagementFactory) {}

  async createUser(req: Request, res: Response): Promise<void> {
    try {
      const useCase = this.userFactory.createUserUseCase();

      const request = new CreateUserRequest(
        req.body.email,
        req.body.firstName,
        req.body.lastName
      );

      const response = await useCase.execute(request);

      res.status(201).json({
        success: true,
        data: response,
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message,
      });
    }
  }

  async getUser(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.userFactory.getUserRepository();
      const userId = UserId.fromString(req.params.id);
      const user = await repository.findById(userId);

      if (!user) {
        res.status(404).json({
          success: false,
          error: "User not found",
        });
        return;
      }

      res.json({
        success: true,
        data: {
          id: user.getId().toString(),
          email: user.getEmail().toString(),
          firstName: user.getFirstName(),
          lastName: user.getLastName(),
          fullName: user.getFullName(),
          createdAt: user.getCreatedAt(),
        },
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  async listUsers(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.userFactory.getUserRepository();
      const users = await repository.findAll();

      const usersData = users.map((user) => ({
        id: user.getId().toString(),
        email: user.getEmail().toString(),
        firstName: user.getFirstName(),
        lastName: user.getLastName(),
        fullName: user.getFullName(),
        createdAt: user.getCreatedAt(),
      }));

      res.json({
        success: true,
        data: usersData,
        count: usersData.length,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }
}
```

Crear `entrypoints/web/controllers/OrderController.ts`:

```typescript
import { Request, Response } from "express";
import { OrderManagementFactory } from "../../../src/order-management/infrastructure/OrderManagementFactory";
import { CreateOrderRequest } from "../../../src/order-management/application/use-cases/CreateOrderUseCase";
import { OrderId } from "../../../src/order-management/domain/value-objects/OrderId";

export class OrderController {
  constructor(private orderFactory: OrderManagementFactory) {}

  async createOrder(req: Request, res: Response): Promise<void> {
    try {
      const useCase = this.orderFactory.createOrderUseCase();

      const request = new CreateOrderRequest(req.body.userId, req.body.items);

      const response = await useCase.execute(request);

      res.status(201).json({
        success: true,
        data: response,
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message,
      });
    }
  }

  async getOrder(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.orderFactory.getOrderRepository();
      const orderId = OrderId.fromString(req.params.id);
      const order = await repository.findById(orderId);

      if (!order) {
        res.status(404).json({
          success: false,
          error: "Order not found",
        });
        return;
      }

      res.json({
        success: true,
        data: {
          id: order.getId().toString(),
          userId: order.getUserId(),
          status: order.getStatus().toString(),
          total: {
            amount: order.getTotal().getAmount(),
            currency: order.getTotal().getCurrency(),
            formatted: order.getTotal().toString(),
          },
          itemCount: order.getItemCount(),
          items: order.getItems().map((item) => ({
            productId: item.getProductId(),
            quantity: item.getQuantity(),
            unitPrice: {
              amount: item.getUnitPrice().getAmount(),
              currency: item.getUnitPrice().getCurrency(),
              formatted: item.getUnitPrice().toString(),
            },
            subtotal: {
              amount: item.getSubtotal().getAmount(),
              currency: item.getSubtotal().getCurrency(),
              formatted: item.getSubtotal().toString(),
            },
          })),
          createdAt: order.getCreatedAt(),
          updatedAt: order.getUpdatedAt(),
        },
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  async getUserOrders(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.orderFactory.getOrderRepository();
      const userId = req.params.userId;
      const orders = await repository.findByUserId(userId);

      const ordersData = orders.map((order) => ({
        id: order.getId().toString(),
        status: order.getStatus().toString(),
        total: order.getTotal().toString(),
        itemCount: order.getItemCount(),
        createdAt: order.getCreatedAt(),
      }));

      res.json({
        success: true,
        data: ordersData,
        count: ordersData.length,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  async listOrders(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.orderFactory.getOrderRepository();
      const orders = await repository.findAll();

      const ordersData = orders.map((order) => ({
        id: order.getId().toString(),
        userId: order.getUserId(),
        status: order.getStatus().toString(),
        total: order.getTotal().toString(),
        itemCount: order.getItemCount(),
        createdAt: order.getCreatedAt(),
      }));

      res.json({
        success: true,
        data: ordersData,
        count: ordersData.length,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }
}
```

### üõ§Ô∏è Routes

Crear `entrypoints/web/routes/userRoutes.ts`:

```typescript
import { Router } from "express";
import { UserController } from "../controllers/UserController";

export function createUserRoutes(userController: UserController): Router {
  const router = Router();

  // POST /api/users - Crear usuario
  router.post("/users", userController.createUser.bind(userController));

  // GET /api/users/:id - Obtener usuario por ID
  router.get("/users/:id", userController.getUser.bind(userController));

  // GET /api/users - Listar todos los usuarios
  router.get("/users", userController.listUsers.bind(userController));

  return router;
}
```

Crear `entrypoints/web/routes/orderRoutes.ts`:

```typescript
import { Router } from "express";
import { OrderController } from "../controllers/OrderController";

export function createOrderRoutes(orderController: OrderController): Router {
  const router = Router();

  // POST /api/orders - Crear orden
  router.post("/orders", orderController.createOrder.bind(orderController));

  // GET /api/orders/:id - Obtener orden por ID
  router.get("/orders/:id", orderController.getOrder.bind(orderController));

  // GET /api/orders - Listar todas las √≥rdenes
  router.get("/orders", orderController.listOrders.bind(orderController));

  // GET /api/users/:userId/orders - √ìrdenes de un usuario espec√≠fico
  router.get(
    "/users/:userId/orders",
    orderController.getUserOrders.bind(orderController)
  );

  return router;
}
```

### üì± App Configuration

Crear `entrypoints/web/app.ts`:

```typescript
import express from "express";
import cors from "cors";
import { Pool } from "pg";
import { createUserRoutes } from "./routes/userRoutes";
import { createOrderRoutes } from "./routes/orderRoutes";
import { UserController } from "./controllers/UserController";
import { OrderController } from "./controllers/OrderController";
import { UserManagementFactory } from "../../src/user-management/infrastructure/UserManagementFactory";
import { OrderManagementFactory } from "../../src/order-management/infrastructure/OrderManagementFactory";

export function createApp(database: Pool): express.Application {
  const app = express();

  // Middleware
  app.use(express.json({ limit: "10mb" }));
  app.use(express.urlencoded({ extended: true }));
  app.use(
    cors({
      origin: process.env.ALLOWED_ORIGINS?.split(",") || [
        "http://localhost:3000",
      ],
      credentials: true,
    })
  );

  // Request logging
  app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
    next();
  });

  // üè≠ Factories - Cada bounded context maneja su infrastructure
  const userFactory = new UserManagementFactory(database);
  const orderFactory = new OrderManagementFactory(database);

  // üéÆ Controllers
  const userController = new UserController(userFactory);
  const orderController = new OrderController(orderFactory);

  // üõ§Ô∏è Routes
  app.use("/api", createUserRoutes(userController));
  app.use("/api", createOrderRoutes(orderController));

  // Health check
  app.get("/health", (req, res) => {
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      boundedContexts: ["user-management", "order-management"],
      environment: process.env.NODE_ENV || "development",
    });
  });

  // API documentation
  app.get("/api", (req, res) => {
    res.json({
      name: "Screaming + Hexagonal Architecture API",
      version: "1.0.0",
      endpoints: {
        users: {
          "POST /api/users": "Create user",
          "GET /api/users": "List users",
          "GET /api/users/:id": "Get user by ID",
        },
        orders: {
          "POST /api/orders": "Create order",
          "GET /api/orders": "List orders",
          "GET /api/orders/:id": "Get order by ID",
          "GET /api/users/:userId/orders": "Get user orders",
        },
        system: {
          "GET /health": "Health check",
          "GET /api": "API documentation",
        },
      },
    });
  });

  // 404 handler
  app.use("*", (req, res) => {
    res.status(404).json({
      success: false,
      error: "Endpoint not found",
      suggestion: "Visit /api for available endpoints",
    });
  });

  // Error handling middleware
  app.use(
    (
      error: any,
      req: express.Request,
      res: express.Response,
      next: express.NextFunction
    ) => {
      console.error("Unhandled error:", error);

      res.status(500).json({
        success: false,
        error: "Internal server error",
        ...(process.env.NODE_ENV === "development" && {
          details: error.message,
        }),
      });
    }
  );

  return app;
}
```

### üöÄ Server

Crear `entrypoints/web/server.ts`:

```typescript
import { createApp } from './app';
import { DatabaseConnection } from '../../shared/database/connection';
import { config } from '../../shared/config';

async function startServer() {
  try {
    console.log('üöÄ Starting server...');

    // üîå Conectar a la base de datos
    console.log('üìä Connecting to database...');
    const database = DatabaseConnection.getInstance();

    // Verificar conexi√≥n
    const isConnected = await DatabaseConnection.testConnection();
    if (!isConnected) {
      throw new Error('Failed to connect to database');
    }
    console.log('‚úÖ Database connected successfully');

    // üì± Crear aplicaci√≥n Express
    const app = createApp(database);

    // üöÄ Iniciar servidor
    const port = config.app.port;
    const server = app.listen(port, () => {
      console.log(`üöÄ Server running on port ${port}`);
      console.log(`üåç Environment: ${config.app.env}`);
      console.log(`üìö API docs: http://localhost:${port}/api`);
      console.log(`‚ù§Ô∏è  Health check: http://localhost:${port}/health`);
      console.log('');
      console.log('üéØ Available endpoints:');
      console.log('   POST /api/users - Create user');
      console.log('   GET  /api/users - List users');
      console.log('   POST /api/orders - Create order');
      console.log('   GET  /api/orders - List orders');
    });

    // Graceful shutdown
    process.on('SIGINT', () => gracefulShutdown(server));
    process.on('SIGTERM', () => gracefulShutdown(server));

  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}

async function gracefulShutdown(server: any‚Ä¶
```
