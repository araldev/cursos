# 🎯 Infrastructure en cada Bounded Context

```plaintext
├── src/                          # 🏢 LÓGICA DE NEGOCIO
│   ├── user-management/
│   │   ├── domain/
│   │   ├── application/
│   │   └── infrastructure/       # 🔌 Infrastructure del USER context
│   │       ├── repositories/
│   │       ├── external-services/
│   │       └── database/
│   └── order-management/
│       ├── domain/
│       ├── application/
│       └── infrastructure/       # 🔌 Infrastructure del ORDER context
│           ├── repositories/
│           ├── external-services/
│           └── database/
├── entrypoints/                  # 🚪 PUNTOS DE ENTRADA
│   ├── web/
│   │   ├── routes/
│   │   ├── app.ts
│   │   └── server.ts
│   ├── cli/
│   └── messaging/
├── shared/                       # 🔄 INFRASTRUCTURE COMPARTIDA
│   ├── database/
│   │   ├── connection.ts
│   │   └── migrations/
│   └── config/
└── config/                       # ⚙️ CONFIGURACIONES
```

## 🔧 IMPLEMENTACIÓN

1. Shared Database Connection 🔄

```js
import { Pool } from 'pg';

export class DatabaseConnection {
  private static instance: Pool;

  static getInstance(): Pool {
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new Pool({
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '5432'),
        database: process.env.DB_NAME || 'app_db',
        user: process.env.DB_USER || 'postgres',
        password: process.env.DB_PASSWORD || 'password',
        max: 20,
      });
    }
    return DatabaseConnection.instance;
  }

  static async close(): Promise<void> {
    if (DatabaseConnection.instance) {
      await DatabaseConnection.instance.end();
    }
  }
}
```

2. Order Management - Infrastructure 📦

```js
import { Pool } from 'pg';
import { OrderRepository } from '../../domain/repositories/OrderRepository';
import { Order } from '../../domain/entities/Order';
import { OrderId } from '../../domain/value-objects/OrderId';

export class PostgreSQLOrderRepository implements OrderRepository {
  constructor(private db: Pool) {}

  async save(order: Order): Promise<void> {
    const client = await this.db.connect();

    try {
      await client.query('BEGIN');

      // Insertar orden
      await client.query(`
        INSERT INTO orders (id, user_id, status, total_amount, total_currency, created_at)
        VALUES ($1, $2, $3, $4, $5, $6)
        ON CONFLICT (id) DO UPDATE SET
          status = EXCLUDED.status,
          total_amount = EXCLUDED.total_amount,
          updated_at = NOW()
      `, [
        order.getId().toString(),
        order.getUserId(),
        order.getStatus(),
        order.getTotal().getAmount(),
        order.getTotal().getCurrency(),
        order.getCreatedAt()
      ]);

      // Insertar items
      await client.query('DELETE FROM order_items WHERE order_id = $1', [order.getId().toString()]);

      for (const item of order.getItems()) {
        await client.query(`
          INSERT INTO order_items (order_id, product_id, quantity, unit_price)
          VALUES ($1, $2, $3, $4)
        `, [
          order.getId().toString(),
          item.getProductId(),
          item.getQuantity(),
          item.getUnitPrice().getAmount()
        ]);
      }

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async findById(id: OrderId): Promise<Order | null> {
    const result = await this.db.query(`
      SELECT
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.id = $1
      GROUP BY o.id
    `, [id.toString()]);

    if (result.rows.length === 0) return null;

    return this.mapToOrder(result.rows[0]);
  }

  async findByUserId(userId: string): Promise<Order[]> {
    const result = await this.db.query(`
      SELECT
        o.*,
        json_agg(
          json_build_object(
            'productId', oi.product_id,
            'quantity', oi.quantity,
            'unitPrice', oi.unit_price
          )
        ) FILTER (WHERE oi.product_id IS NOT NULL) as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.user_id = $1
      GROUP BY o.id
      ORDER BY o.created_at DESC
    `, [userId]);

    return result.rows.map(row => this.mapToOrder(row));
  }

  private mapToOrder(row: any): Order {
    return Order.fromPersistence({
      id: OrderId.fromString(row.id),
      userId: row.user_id,
      status: row.status,
      totalAmount: row.total_amount,
      totalCurrency: row.total_currency,
      createdAt: row.created_at,
      items: row.items || []
    });
  }
}
```

```js
import { PaymentProcessingPort } from '../../application/ports/PaymentProcessingPort';
import { Money } from '../../domain/value-objects/Money';
import { PaymentMethod, PaymentResult } from '../../domain/value-objects/Payment';

export class StripePaymentService implements PaymentProcessingPort {
  constructor(private stripeApiKey: string) {}

  async processPayment(amount: Money, paymentMethod: PaymentMethod): Promise<PaymentResult> {
    try {
      // Simulación de llamada a Stripe
      const stripeResponse = await this.callStripeAPI({
        amount: amount.getAmount() * 100, // Stripe usa centavos
        currency: amount.getCurrency().toLowerCase(),
        payment_method: paymentMethod.getToken(),
        confirm: true
      });

      if (stripeResponse.status === 'succeeded') {
        return PaymentResult.success(
          stripeResponse.id,
          amount,
          new Date()
        );
      } else {
        return PaymentResult.failure(
          stripeResponse.failure_reason || 'Payment failed'
        );
      }
    } catch (error) {
      return PaymentResult.failure(error.message);
    }
  }

  async refundPayment(transactionId: string, amount: Money): Promise<RefundResult> {
    // Implementación de reembolso
    // ...
  }

  private async callStripeAPI(data: any): Promise<any> {
    // Implementación real de Stripe API
    // Por ahora simulamos
    return {
      id: 'pi_' + Date.now(),
      status: 'succeeded',
      amount: data.amount,
      currency: data.currency
    };
  }
}
```

3. Order Management - Factory 🏭

```js
import { Pool } from 'pg';
import { PostgreSQLOrderRepository } from './repositories/PostgreSQLOrderRepository';
import { StripePaymentService } from './external-services/StripePaymentService';
import { CreateOrderUseCase } from '../application/use-cases/CreateOrderUseCase';
import { ProcessPaymentUseCase } from '../application/use-cases/ProcessPaymentUseCase';
import { CancelOrderUseCase } from '../application/use-cases/CancelOrderUseCase';

// Factory que ensambla todo el bounded context
export class OrderManagementFactory {
  private orderRepository: PostgreSQLOrderRepository;
  private paymentService: StripePaymentService;

  constructor(private database: Pool) {
    this.setupInfrastructure();
  }

  private setupInfrastructure(): void {
    // Repositories
    this.orderRepository = new PostgreSQLOrderRepository(this.database);

    // External Services
    this.paymentService = new StripePaymentService(
      process.env.STRIPE_SECRET_KEY || 'sk_test_...'
    );
  }

  // 🎯 Use Cases
  createOrderUseCase(): CreateOrderUseCase {
    return new CreateOrderUseCase(
      this.orderRepository
    );
  }

  processPaymentUseCase(): ProcessPaymentUseCase {
    return new ProcessPaymentUseCase(
      this.orderRepository,
      this.paymentService
    );
  }

  cancelOrderUseCase(): CancelOrderUseCase {
    return new CancelOrderUseCase(
      this.orderRepository
    );
  }

  // 🗄️ Repositories (para otros bounded contexts)
  getOrderRepository(): PostgreSQLOrderRepository {
    return this.orderRepository;
  }
}
```

4. User Management - Infrastructure 👥

```js
import { Pool } from 'pg';
import { UserRepository } from '../../domain/repositories/UserRepository';
import { User } from '../../domain/entities/User';
import { UserId } from '../../domain/value-objects/UserId';

export class PostgreSQLUserRepository implements UserRepository {
  constructor(private db: Pool) {}

  async save(user: User): Promise<void> {
    await this.db.query(`
      INSERT INTO users (id, email, first_name, last_name, created_at)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (id) DO UPDATE SET
        email = EXCLUDED.email,
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        updated_at = NOW()
    `, [
      user.getId().toString(),
      user.getEmail().toString(),
      user.getFirstName(),
      user.getLastName(),
      user.getCreatedAt()
    ]);
  }

  async findById(id: UserId): Promise<User | null> {
    const result = await this.db.query(`
      SELECT * FROM users WHERE id = $1
    `, [id.toString()]);

    if (result.rows.length === 0) return null;

    return this.mapToUser(result.rows[0]);
  }

  async findByEmail(email: string): Promise<User | null> {
    const result = await this.db.query(`
      SELECT * FROM users WHERE email = $1
    `, [email]);

    if (result.rows.length === 0) return null;

    return this.mapToUser(result.rows[0]);
  }

  private mapToUser(row: any): User {
    return User.fromPersistence({
      id: UserId.fromString(row.id),
      email: row.email,
      firstName: row.first_name,
      lastName: row.last_name,
      createdAt: row.created_at
    });
  }
}
```

```js
import { Pool } from 'pg';
import { PostgreSQLUserRepository } from './repositories/PostgreSQLUserRepository';
import { EmailService } from './external-services/EmailService';
import { CreateUserUseCase } from '../application/use-cases/CreateUserUseCase';
import { UpdateUserProfileUseCase } from '../application/use-cases/UpdateUserProfileUseCase';

export class UserManagementFactory {
  private userRepository: PostgreSQLUserRepository;
  private emailService: EmailService;

  constructor(private database: Pool) {
    this.setupInfrastructure();
  }

  private setupInfrastructure(): void {
    this.userRepository = new PostgreSQLUserRepository(this.database);
    this.emailService = new EmailService(
      process.env.SENDGRID_API_KEY || ''
    );
  }

  // Use Cases
  createUserUseCase(): CreateUserUseCase {
    return new CreateUserUseCase(
      this.userRepository,
      this.emailService
    );
  }

  updateUserProfileUseCase(): UpdateUserProfileUseCase {
    return new UpdateUserProfileUseCase(
      this.userRepository
    );
  }

  // Repository access
  getUserRepository(): PostgreSQLUserRepository {
    return this.userRepository;
  }
}
```

5. Entrypoints - Controllers Actualizados 🎮

```js
import { Request, Response } from 'express';
import { OrderManagementFactory } from '../../../src/order-management/infrastructure/OrderManagementFactory';
import { CreateOrderRequest } from '../../../src/order-management/application/use-cases/CreateOrderUseCase';
import { OrderId } from '../../../src/order-management/domain/value-objects/OrderId';

export class OrderController {
  constructor(private orderFactory: OrderManagementFactory) {}

  // POST /api/orders
  async createOrder(req: Request, res: Response): Promise<void> {
    try {
      const useCase = this.orderFactory.createOrderUseCase();

      const request = new CreateOrderRequest(
        req.body.userId,
        req.body.items
      );

      const response = await useCase.execute(request);

      res.status(201).json({
        success: true,
        data: { orderId: response.orderId }
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }

  // GET /api/orders/:id
  async getOrder(req: Request, res: Response): Promise<void> {
    try {
      const repository = this.orderFactory.getOrderRepository();
      const orderId = OrderId.fromString(req.params.id);
      const order = await repository.findById(orderId);

      if (!order) {
        res.status(404).json({
          success: false,
          error: 'Order not found'
        });
        return;
      }

      res.json({
        success: true,
        data: {
          id: order.getId().toString(),
          userId: order.getUserId(),
          status: order.getStatus(),
          total: {
            amount: order.getTotal().getAmount(),
            currency: order.getTotal().getCurrency()
          },
          items: order.getItems().map(item => ({
            productId: item.getProductId(),
            quantity: item.getQuantity(),
            unitPrice: item.getUnitPrice().getAmount()
          })),
          createdAt: order.getCreatedAt()
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }

  // POST /api/orders/:id/payment
  async processPayment(req: Request, res: Response): Promise<void> {
    try {
      const useCase = this.orderFactory.processPaymentUseCase();

      const request = new ProcessPaymentRequest(
        OrderId.fromString(req.params.id),
        req.body.paymentMethod
      );

      await useCase.execute(request);
      res.json({ success: true });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }

  // DELETE /api/orders/:id
  async cancelOrder(req: Request, res: Response): Promise<void> {
    try {
      const useCase = this.orderFactory.cancelOrderUseCase();

      const request = new CancelOrderRequest(
        OrderId.fromString(req.params.id)
      );

      await useCase.execute(request);
      res.json({ success: true });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }
}
```

6. Entrypoints - App Principal 📱

```js
import express from "express";
import cors from "cors";
import { Pool } from "pg";
import { createOrderRoutes } from "./routes/orderRoutes";
import { createUserRoutes } from "./routes/userRoutes";
import { OrderController } from "./controllers/OrderController";
import { UserController } from "./controllers/UserController";

// Factories de cada bounded context
import { OrderManagementFactory } from "../../src/order-management/infrastructure/OrderManagementFactory";
import { UserManagementFactory } from "../../src/user-management/infrastructure/UserManagementFactory";

export function createApp(database: Pool): express.Application {
  const app = express();

  // Middleware
  app.use(express.json());
  app.use(cors());
  app.use(express.urlencoded({ extended: true }));

  // 🏭 FACTORIES - Cada bounded context maneja su propia infrastructure
  const orderFactory = new OrderManagementFactory(database);
  const userFactory = new UserManagementFactory(database);

  // 🎮 CONTROLLERS - Usan las factories
  const orderController = new OrderController(orderFactory);
  const userController = new UserController(userFactory);

  // 🛤️ ROUTES
  app.use("/api", createOrderRoutes(orderController));
  app.use("/api", createUserRoutes(userController));

  // Health check
  app.get("/health", (req, res) => {
    res.json({
      status: "ok",
      timestamp: new Date().toISOString(),
      boundedContexts: ["order-management", "user-management"],
    });
  });

  // Error handling middleware
  app.use(
    (
      error: any,
      req: express.Request,
      res: express.Response,
      next: express.NextFunction
    ) => {
      console.error("Unhandled error:", error);
      res.status(500).json({
        success: false,
        error: "Internal server error",
      });
    }
  );

  return app;
}
```

## ✅ VENTAJAS DE ESTA ESTRUCTURA

### 🎯 Encapsulamiento

- Cada bounded context maneja su propia infrastructure
- No hay dependencies cruzadas entre contexts
- Fácil evolución independiente

### 🏭 Factory Pattern

- Cada context tiene su factory
- Ensamblaje de dependencias centralizado por context
- Fácil testing con mocks

### 🔄 Compartir Solo lo Necesario

- Database connection compartida (eficiencia)
- Config compartida
- Utilities compartidas

### 📦 Desacoplamiento

- Controllers no conocen implementaciones específicas
- Fácil cambiar de PostgreSQL a MongoDB en un context
- Fácil cambiar de Stripe a PayPal

### 🎯 FLUJO ACTUALIZADO

```plaintext
1. 🚀 server.ts inicia
2. 🔌 Crea conexión compartida a BD
3. 📱 app.ts recibe la conexión
4. 🏭 Crea factories por bounded context
5. 🎮 Controllers usan factories para obtener use cases
6. ⚡ Use cases usan repositories del mismo context
7. 💾 Repositories usan la conexión compartida
```
